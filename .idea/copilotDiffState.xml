<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/TASK_WRITE_FEATURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TASK_WRITE_FEATURE.md" />
              <option name="updatedContent" value="Study Log - feature/task-write&#10;&#10;What I did (branch: feature/task-write)&#10;&#10;- Created feature/task-write branch for the Task Log write functionality&#10;- Implemented the mandatory Database Write functionality:&#10;  - `Task.java` - Model class to represent a task&#10;  - `TaskDatabaseHelper.java` - SQLite database helper for CRUD operations&#10;  - Updated `TaskLogFragment.java` - Fragment with EditText input and Save button&#10;  - Updated `fragment_task_log.xml` - UI layout with EditText and Save button&#10;  &#10;Feature Implementation Details&#10;&#10;TaskLogFragment:&#10;- Displays a simple UI with a heading &quot;Add New Task&quot;&#10;- Contains an EditText field (id: etTaskName) with placeholder text &quot;Enter task name (e.g., Review WS10)&quot;&#10;- Has a &quot;Save Task&quot; button (id: btnSaveTask)&#10;- When button is clicked:&#10;  1. Validates that the task name is not empty&#10;  2. Saves the task to SQLite database using TaskDatabaseHelper&#10;  3. Shows &quot;Task Saved!&quot; Toast message on success&#10;  4. Clears the EditText for next input&#10;  5. Shows error message if save fails&#10;&#10;TaskDatabaseHelper:&#10;- Creates and manages SQLite database named &quot;studylog.db&quot;&#10;- Creates &quot;tasks&quot; table with columns:&#10;  - _id (INTEGER PRIMARY KEY AUTOINCREMENT)&#10;  - task_name (TEXT NOT NULL)&#10;  - created_at (LONG NOT NULL - timestamp)&#10;- Provides insertTask(String taskName) method to save tasks&#10;&#10;Task Model:&#10;- Simple POJO class with getters/setters for:&#10;  - id&#10;  - taskName&#10;  - createdAt (timestamp)&#10;&#10;Files Changed/Created:&#10;- app/src/main/java/com/example/studylog/Task.java (NEW)&#10;- app/src/main/java/com/example/studylog/TaskDatabaseHelper.java (NEW)&#10;- app/src/main/java/com/example/studylog/TaskLogFragment.java (UPDATED)&#10;- app/src/main/res/layout/fragment_task_log.xml (UPDATED)&#10;&#10;Local Commits:&#10;✓ Commit created: &quot;feat: add task write functionality with SQLite database&quot;&#10;✓ Branch feature/task-write created and committed&#10;✓ Merged into main branch&#10;&#10;GitHub Push Status:&#10;- Attempted to push to https://github.com/DilushaGalhena/Study-Log.git&#10;- GitHub server returned &quot;Internal Server Error&quot; - this is a temporary server issue&#10;- All commits are properly created locally&#10;- Can retry push when GitHub service is available&#10;&#10;Testing Checklist:&#10;1. In Android Studio: Sync Gradle and Build the project&#10;2. Run app on device/emulator&#10;3. Navigate to &quot;Tasks&quot; tab (nav_tasks) on bottom navigation&#10;4. Enter a task name (e.g., &quot;Review WS10&quot;)&#10;5. Click &quot;Save Task&quot; button&#10;6. Verify &quot;Task Saved!&quot; Toast appears&#10;7. EditText should clear and be ready for next task&#10;&#10;Database File Location:&#10;- Path: /data/data/com.example.studylog/databases/studylog.db&#10;- Can be viewed using Android Studio's Device File Explorer after running on device/emulator&#10;&#10;Integration Notes:&#10;- TaskLogFragment is already wired in MainActivity (referenced as nav_tasks)&#10;- No additional manifest changes needed&#10;- Fragment uses standard lifecycle methods&#10;- Database is initialized on first save&#10;&#10;Troubleshooting:&#10;- If push still fails: Try `git push --force-with-lease origin main` after verifying remote URL&#10;- Remote configured as: https://github.com/DilushaGalhena/Study-Log.git&#10;- Can manually create a Pull Request on GitHub to merge feature/task-write into main&#10;&#10;Next Steps for Other Members:&#10;- Member 1: Fact Feed feature (already completed in previous branch)&#10;- Member 3: Quick Contact &amp; API 2&#10;- Member 4: Profile with photo capture&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/studylog/Task.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/studylog/Task.java" />
              <option name="originalContent" value="package com.example.studylog;&#10;&#10;public class Task {&#10;    private int id;&#10;    private String taskName;&#10;    private long createdAt;&#10;&#10;    public Task(String taskName) {&#10;        this.taskName = taskName;&#10;        this.createdAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public Task(int id, String taskName, long createdAt) {&#10;        this.id = id;&#10;        this.taskName = taskName;&#10;        this.createdAt = createdAt;&#10;    }&#10;&#10;    public int getId() {&#10;        return id;&#10;    }&#10;&#10;    public void setId(int id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public String getTaskName() {&#10;        return taskName;&#10;    }&#10;&#10;    public void setTaskName(String taskName) {&#10;        this.taskName = taskName;&#10;    }&#10;&#10;    public long getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    public void setCreatedAt(long createdAt) {&#10;        this.createdAt = createdAt;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.studylog;&#10;&#10;import android.content.ContentValues;&#10;import android.database.Cursor;&#10;import android.os.Parcel;&#10;import android.os.Parcelable;&#10;&#10;import java.util.Objects;&#10;&#10;public class Task implements Parcelable {&#10;    // Database column names (convenience for DB helpers)&#10;    public static final String COL_ID = &quot;id&quot;;&#10;    public static final String COL_TASK_NAME = &quot;task_name&quot;;&#10;    public static final String COL_CREATED_AT = &quot;created_at&quot;;&#10;&#10;    private int id;&#10;    private String taskName;&#10;    private long createdAt;&#10;&#10;    public Task(String taskName) {&#10;        this.taskName = taskName;&#10;        this.createdAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public Task(int id, String taskName, long createdAt) {&#10;        this.id = id;&#10;        this.taskName = taskName;&#10;        this.createdAt = createdAt;&#10;    }&#10;&#10;    // Create from a Cursor (null-safe)&#10;    public static Task fromCursor(Cursor c) {&#10;        if (c == null) return null;&#10;        int id = -1;&#10;        long created = System.currentTimeMillis();&#10;        String name = null;&#10;&#10;        int idx;&#10;        idx = c.getColumnIndex(COL_ID);&#10;        if (idx != -1) id = c.getInt(idx);&#10;        idx = c.getColumnIndex(COL_TASK_NAME);&#10;        if (idx != -1) name = c.getString(idx);&#10;        idx = c.getColumnIndex(COL_CREATED_AT);&#10;        if (idx != -1) created = c.getLong(idx);&#10;&#10;        return new Task(id, name, created);&#10;    }&#10;&#10;    // Convert to ContentValues for inserting/updating in DB&#10;    public ContentValues toContentValues() {&#10;        ContentValues values = new ContentValues();&#10;        if (taskName != null) values.put(COL_TASK_NAME, taskName);&#10;        values.put(COL_CREATED_AT, createdAt);&#10;        // Do not put id for inserts (usually auto-generated) but allow for explicit updates&#10;        if (id &gt; 0) values.put(COL_ID, id);&#10;        return values;&#10;    }&#10;&#10;    // Parcelable implementation&#10;    protected Task(Parcel in) {&#10;        id = in.readInt();&#10;        taskName = in.readString();&#10;        createdAt = in.readLong();&#10;    }&#10;&#10;    @Override&#10;    public void writeToParcel(Parcel dest, int flags) {&#10;        dest.writeInt(id);&#10;        dest.writeString(taskName);&#10;        dest.writeLong(createdAt);&#10;    }&#10;&#10;    @Override&#10;    public int describeContents() {&#10;        return 0;&#10;    }&#10;&#10;    public static final Creator&lt;Task&gt; CREATOR = new Creator&lt;Task&gt;() {&#10;        @Override&#10;        public Task createFromParcel(Parcel in) {&#10;            return new Task(in);&#10;        }&#10;&#10;        @Override&#10;        public Task[] newArray(int size) {&#10;            return new Task[size];&#10;        }&#10;    };&#10;&#10;    public int getId() {&#10;        return id;&#10;    }&#10;&#10;    public void setId(int id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public String getTaskName() {&#10;        return taskName;&#10;    }&#10;&#10;    public void setTaskName(String taskName) {&#10;        this.taskName = taskName;&#10;    }&#10;&#10;    public long getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    public void setCreatedAt(long createdAt) {&#10;        this.createdAt = createdAt;&#10;    }&#10;&#10;    @Override&#10;    public boolean equals(Object o) {&#10;        if (this == o) return true;&#10;        if (!(o instanceof Task)) return false;&#10;        Task task = (Task) o;&#10;        return id == task.id &amp;&amp;&#10;                createdAt == task.createdAt &amp;&amp;&#10;                Objects.equals(taskName, task.taskName);&#10;    }&#10;&#10;    @Override&#10;    public int hashCode() {&#10;        return Objects.hash(id, taskName, createdAt);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Task{&quot; +&#10;                &quot;id=&quot; + id +&#10;                &quot;, taskName='&quot; + taskName + '\'' +&#10;                &quot;, createdAt=&quot; + createdAt +&#10;                '}';&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/studylog/TaskAdapter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/studylog/TaskAdapter.java" />
              <option name="updatedContent" value="package com.example.studylog;&#10;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.TextView;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;&#10;import java.text.SimpleDateFormat;&#10;import java.util.List;&#10;import java.util.Locale;&#10;&#10;public class TaskAdapter extends RecyclerView.Adapter&lt;TaskAdapter.TaskViewHolder&gt; {&#10;    private List&lt;Task&gt; tasks;&#10;    private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;MMM dd, yyyy HH:mm&quot;, Locale.getDefault());&#10;&#10;    public TaskAdapter(List&lt;Task&gt; tasks) {&#10;        this.tasks = tasks;&#10;    }&#10;&#10;    @NonNull&#10;    @Override&#10;    public TaskViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {&#10;        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_task, parent, false);&#10;        return new TaskViewHolder(view);&#10;    }&#10;&#10;    @Override&#10;    public void onBindViewHolder(@NonNull TaskViewHolder holder, int position) {&#10;        Task task = tasks.get(position);&#10;        holder.tvTaskName.setText(task.getTaskName());&#10;        &#10;        String dateStr = dateFormat.format(new java.util.Date(task.getCreatedAt()));&#10;        holder.tvTaskDate.setText(dateStr);&#10;    }&#10;&#10;    @Override&#10;    public int getItemCount() {&#10;        return tasks.size();&#10;    }&#10;&#10;    public void updateTasks(List&lt;Task&gt; newTasks) {&#10;        this.tasks = newTasks;&#10;        notifyDataSetChanged();&#10;    }&#10;&#10;    public static class TaskViewHolder extends RecyclerView.ViewHolder {&#10;        TextView tvTaskName;&#10;        TextView tvTaskDate;&#10;&#10;        public TaskViewHolder(@NonNull View itemView) {&#10;            super(itemView);&#10;            tvTaskName = itemView.findViewById(R.id.tvTaskName);&#10;            tvTaskDate = itemView.findViewById(R.id.tvTaskDate);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/studylog/TaskDatabaseHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/studylog/TaskDatabaseHelper.java" />
              <option name="originalContent" value="package com.example.studylog;&#10;&#10;import android.content.ContentValues;&#10;import android.content.Context;&#10;import android.database.sqlite.SQLiteDatabase;&#10;import android.database.sqlite.SQLiteOpenHelper;&#10;&#10;public class TaskDatabaseHelper extends SQLiteOpenHelper {&#10;    private static final String DATABASE_NAME = &quot;studylog.db&quot;;&#10;    private static final int DATABASE_VERSION = 1;&#10;    public static final String TABLE_TASKS = &quot;tasks&quot;;&#10;    public static final String COLUMN_ID = &quot;_id&quot;;&#10;    public static final String COLUMN_TASK_NAME = &quot;task_name&quot;;&#10;    public static final String COLUMN_CREATED_AT = &quot;created_at&quot;;&#10;&#10;    public TaskDatabaseHelper(Context context) {&#10;        super(context, DATABASE_NAME, null, DATABASE_VERSION);&#10;    }&#10;&#10;    @Override&#10;    public void onCreate(SQLiteDatabase db) {&#10;        String createTableSQL = &quot;CREATE TABLE &quot; + TABLE_TASKS + &quot; (&quot; +&#10;                COLUMN_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; +&#10;                COLUMN_TASK_NAME + &quot; TEXT NOT NULL, &quot; +&#10;                COLUMN_CREATED_AT + &quot; LONG NOT NULL)&quot;;&#10;        db.execSQL(createTableSQL);&#10;    }&#10;&#10;    @Override&#10;    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {&#10;        db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_TASKS);&#10;        onCreate(db);&#10;    }&#10;&#10;    public long insertTask(String taskName) {&#10;        SQLiteDatabase db = this.getWritableDatabase();&#10;        ContentValues values = new ContentValues();&#10;        values.put(COLUMN_TASK_NAME, taskName);&#10;        values.put(COLUMN_CREATED_AT, System.currentTimeMillis());&#10;        return db.insert(TABLE_TASKS, null, values);&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.studylog;&#13;&#10;&#13;&#10;import android.content.ContentValues;&#13;&#10;import android.content.Context;&#13;&#10;import android.database.sqlite.SQLiteDatabase;&#13;&#10;import android.database.sqlite.SQLiteOpenHelper;&#13;&#10;&#13;&#10;public class TaskDatabaseHelper extends SQLiteOpenHelper {&#13;&#10;    private static final String DATABASE_NAME = &quot;studylog.db&quot;;&#13;&#10;    private static final int DATABASE_VERSION = 1;&#13;&#10;    public static final String TABLE_TASKS = &quot;tasks&quot;;&#13;&#10;    public static final String COLUMN_ID = &quot;_id&quot;;&#13;&#10;    public static final String COLUMN_TASK_NAME = &quot;task_name&quot;;&#13;&#10;    public static final String COLUMN_CREATED_AT = &quot;created_at&quot;;&#13;&#10;&#13;&#10;    public TaskDatabaseHelper(Context context) {&#13;&#10;        super(context, DATABASE_NAME, null, DATABASE_VERSION);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void onCreate(SQLiteDatabase db) {&#13;&#10;        String createTableSQL = &quot;CREATE TABLE &quot; + TABLE_TASKS + &quot; (&quot; +&#13;&#10;                COLUMN_ID + &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; +&#13;&#10;                COLUMN_TASK_NAME + &quot; TEXT NOT NULL, &quot; +&#13;&#10;                COLUMN_CREATED_AT + &quot; LONG NOT NULL)&quot;;&#13;&#10;        db.execSQL(createTableSQL);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {&#13;&#10;        db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_TASKS);&#13;&#10;        onCreate(db);&#13;&#10;    }&#13;&#10;&#13;&#10;    public long insertTask(String taskName) {&#10;        SQLiteDatabase db = this.getWritableDatabase();&#10;        ContentValues values = new ContentValues();&#10;        values.put(COLUMN_TASK_NAME, taskName);&#10;        values.put(COLUMN_CREATED_AT, System.currentTimeMillis());&#10;        return db.insert(TABLE_TASKS, null, values);&#10;    }&#10;&#10;    public java.util.List&lt;Task&gt; getAllTasks() {&#10;        java.util.List&lt;Task&gt; tasks = new java.util.ArrayList&lt;&gt;();&#10;        SQLiteDatabase db = this.getReadableDatabase();&#10;        &#10;        android.database.Cursor cursor = db.query(&#10;                TABLE_TASKS,&#10;                null,&#10;                null,&#10;                null,&#10;                null,&#10;                null,&#10;                COLUMN_CREATED_AT + &quot; DESC&quot;&#10;        );&#10;        &#10;        if (cursor.moveToFirst()) {&#10;            do {&#10;                int id = cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_ID));&#10;                String taskName = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_TASK_NAME));&#10;                long createdAt = cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_CREATED_AT));&#10;                &#10;                tasks.add(new Task(id, taskName, createdAt));&#10;            } while (cursor.moveToNext());&#10;        }&#10;        cursor.close();&#10;        &#10;        return tasks;&#10;    }&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/studylog/TaskLogFragment.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/studylog/TaskLogFragment.java" />
              <option name="originalContent" value="package com.example.studylog;&#10;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.fragment.app.Fragment;&#10;&#10;import com.example.studylog.R;&#10;&#10;public class TaskLogFragment extends Fragment {&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.fragment_task_log, container, false);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.studylog;&#10;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.Button;&#10;import android.widget.EditText;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.recyclerview.widget.LinearLayoutManager;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;&#10;import java.util.List;&#10;&#10;public class TaskLogFragment extends Fragment {&#10;    private EditText etTaskName;&#10;    private Button btnSaveTask;&#10;    private TaskDatabaseHelper dbHelper;&#10;    private RecyclerView recyclerViewTasks;&#10;    private TaskAdapter taskAdapter;&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.fragment_task_log, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(view, savedInstanceState);&#10;        &#10;        etTaskName = view.findViewById(R.id.etTaskName);&#10;        btnSaveTask = view.findViewById(R.id.btnSaveTask);&#10;        recyclerViewTasks = view.findViewById(R.id.recyclerViewTasks);&#10;        &#10;        dbHelper = new TaskDatabaseHelper(requireContext());&#10;        &#10;        // Setup RecyclerView&#10;        recyclerViewTasks.setLayoutManager(new LinearLayoutManager(requireContext()));&#10;        &#10;        // Load and display tasks&#10;        loadTasks();&#10;        &#10;        btnSaveTask.setOnClickListener(v -&gt; saveTask());&#10;    }&#10;&#10;    private void loadTasks() {&#10;        List&lt;Task&gt; tasks = dbHelper.getAllTasks();&#10;        taskAdapter = new TaskAdapter(tasks);&#10;        recyclerViewTasks.setAdapter(taskAdapter);&#10;    }&#10;&#10;    private void saveTask() {&#10;        String taskName = etTaskName.getText().toString().trim();&#10;&#10;        if (taskName.isEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;Please enter a task name&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        long result = dbHelper.insertTask(taskName);&#10;&#10;        if (result != -1) {&#10;            Toast.makeText(requireContext(), &quot;Task Saved!&quot;, Toast.LENGTH_SHORT).show();&#10;            etTaskName.setText(&quot;&quot;);&#10;            &#10;            // Refresh the task list&#10;            loadTasks();&#10;        } else {&#10;            Toast.makeText(requireContext(), &quot;Failed to save task&quot;, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/task_item_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/task_item_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &lt;solid android:color=&quot;#F5F5F5&quot; /&gt;&#10;    &lt;corners android:radius=&quot;8dp&quot; /&gt;&#10;    &lt;stroke&#10;        android:width=&quot;1dp&quot;&#10;        android:color=&quot;#E0E0E0&quot; /&gt;&#10;&lt;/shape&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_task_log.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_task_log.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Task Log Coming Soon&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        android:textSize=&quot;18sp&quot; /&gt;&#10;&#10;&lt;/FrameLayout&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Add New Task&quot;&#10;        android:textSize=&quot;24sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;EditText&#10;        android:id=&quot;@+id/etTaskName&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:hint=&quot;Enter task name (e.g., Review WS10)&quot;&#10;        android:inputType=&quot;text&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&#10;        android:minHeight=&quot;48dp&quot; /&gt;&#10;&#10;    &lt;Button&#10;        android:id=&quot;@+id/btnSaveTask&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Save Task&quot;&#10;        android:minHeight=&quot;48dp&quot;&#10;        android:layout_marginBottom=&quot;24dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Your Tasks&quot;&#10;        android:textSize=&quot;18sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:layout_marginBottom=&quot;12dp&quot; /&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/recyclerViewTasks&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/item_task.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/item_task.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;12dp&quot;&#10;    android:layout_marginBottom=&quot;8dp&quot;&#10;    android:background=&quot;@drawable/task_item_background&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvTaskName&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:textColor=&quot;@android:color/black&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvTaskDate&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:textSize=&quot;12sp&quot;&#10;        android:textColor=&quot;@android:color/darker_gray&quot;&#10;        android:layout_marginTop=&quot;4dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;&#10;" />
        <entry key="$PROJECT_DIR$/API_DEBUG_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/API_DEBUG_GUIDE.md" />
              <option name="updatedContent" value="# API Integration Debug Guide&#10;&#10;## Issue: App showing &quot;Error fetching data&quot;&#10;&#10;## Fixes Applied:&#10;&#10;### 1. Enhanced Error Handling &amp; Logging&#10;- Added comprehensive logging with TAG &quot;MainActivity&quot;&#10;- Added specific error messages for different HTTP status codes&#10;- Added timeout and network error detection&#10;- Added JSON parsing error handling&#10;&#10;### 2. Network Security Configuration&#10;- Created `network_security_config.xml` to handle HTTPS/HTTP issues&#10;- Added `android:usesCleartextTraffic=&quot;true&quot;` in AndroidManifest&#10;- Allow cleartext traffic for worldtimeapi.org domain&#10;&#10;### 3. Backup API System&#10;- Primary: `https://worldtimeapi.org/api/timezone/Europe/London`&#10;- Backup: `http://worldtimeapi.org/api/timezone/Europe/London` (HTTP fallback)&#10;- Alternative: `https://timeapi.io/api/Time/current/zone?timeZone=Europe/London`&#10;&#10;### 4. Comprehensive API Testing&#10;- Added `testAllAPIs()` method to test all endpoints&#10;- Click &quot;Error fetching data&quot; text to run full API diagnostics&#10;- Will show which API works and detailed error messages&#10;&#10;### 5. Improved Request Configuration&#10;- Added proper User-Agent header&#10;- Added Accept: application/json header&#10;- Increased timeout to 15 seconds&#10;- Disabled automatic retries to avoid delays&#10;&#10;## Testing Steps:&#10;&#10;### Method 1: Check Logs&#10;1. Connect device/emulator to Android Studio&#10;2. Open Logcat and filter by &quot;MainActivity&quot;&#10;3. Launch app and watch for API logs&#10;4. Look for specific error messages&#10;&#10;### Method 2: Use Built-in Diagnostics&#10;1. Launch the app&#10;2. If you see &quot;Error fetching data&quot;, tap on the text&#10;3. App will run comprehensive API tests&#10;4. Will show which API works or specific error messages&#10;&#10;### Method 3: Manual API Testing&#10;Test the APIs directly:&#10;- Primary: `curl &quot;https://worldtimeapi.org/api/timezone/Europe/London&quot;`&#10;- Backup: `curl &quot;http://worldtimeapi.org/api/timezone/Europe/London&quot;`&#10;- Alternative: `curl &quot;https://timeapi.io/api/Time/current/zone?timeZone=Europe/London&quot;`&#10;&#10;## Expected Behavior:&#10;- Loading: &quot;Loading current time...&quot;&#10;- Success: &quot;Current Date/Time: 2024-11-12T14:30:25.123456+00:00&quot;&#10;- Error: Specific error message + &quot;- Tap to retry&quot;&#10;&#10;## Common Issues &amp; Solutions:&#10;&#10;### 1. SSL/TLS Issues&#10;- **Solution**: Network security config allows both HTTP and HTTPS&#10;- **Backup**: Falls back to HTTP if HTTPS fails&#10;&#10;### 2. API Endpoint Down&#10;- **Solution**: Multiple backup APIs configured&#10;- **Fallback**: TimeAPI.io as alternative service&#10;&#10;### 3. Network Connectivity&#10;- **Detection**: Shows &quot;No internet connection available&quot;&#10;- **Solution**: Check device network settings&#10;&#10;### 4. Firewall/Corporate Network&#10;- **Detection**: Shows timeout or connection errors&#10;- **Solution**: May need to test on different network&#10;&#10;### 5. JSON Parsing Issues&#10;- **Detection**: Shows &quot;Error parsing date/time&quot;&#10;- **Logging**: Full response logged for debugging&#10;&#10;## Debug Commands:&#10;```bash&#10;# Build and install&#10;./gradlew assembleDebug&#10;&#10;# Install on connected device&#10;adb install app/build/outputs/apk/debug/app-debug.apk&#10;&#10;# View real-time logs&#10;adb logcat | grep MainActivity&#10;```&#10;&#10;## Files Modified:&#10;- `MainActivity.java` - Enhanced API integration with comprehensive error handling&#10;- `AndroidManifest.xml` - Added network security configuration&#10;- `res/xml/network_security_config.xml` - Network security rules&#10;- `res/values/strings.xml` - Added backup API URLs&#10;&#10;The app should now provide detailed error messages and automatically try multiple APIs to ensure the time data loads successfully." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/VOLLEY_REQUEST_EXAMPLE.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/VOLLEY_REQUEST_EXAMPLE.java" />
              <option name="updatedContent" value="/**&#10; * VOLLEY REQUEST IMPLEMENTATION - COMPLETE EXAMPLE&#10; * This file demonstrates the exact Volley request pattern specified by the user&#10; */&#10;&#10;// STANDARD VOLLEY REQUEST IMPLEMENTATION&#10;private void makeAPIRequest() {&#10;    // 1. Set up the API URL&#10;    String apiUrl = &quot;https://worldtimeapi.org/api/timezone/Europe/London&quot;; // Use your actual API URL&#10;    &#10;    // 2. Update UI to show loading state&#10;    apiResultTextView.setText(&quot;Loading...&quot;);&#10;    &#10;    // 3. Create Volley RequestQueue&#10;    RequestQueue queue = Volley.newRequestQueue(this);&#10;    &#10;    // 4. Create StringRequest with proper error handling&#10;    StringRequest stringRequest = new StringRequest(Request.Method.GET, apiUrl,&#10;        new Response.Listener&lt;String&gt;() {&#10;            @Override&#10;            public void onResponse(String response) {&#10;                try {&#10;                    // 5. Parse the JSON response&#10;                    JSONObject jsonObject = new JSONObject(response);&#10;                    String data = jsonObject.getString(&quot;datetime&quot;); // Parse the required data from the response&#10;                    &#10;                    // 6. Update the TextView with the data (SUCCESS STATE)&#10;                    apiResultTextView.setText(&quot;Data: &quot; + data); // Update the TextView with the data&#10;                    &#10;                    Log.d(&quot;API_SUCCESS&quot;, &quot;Data fetched successfully: &quot; + data);&#10;                    &#10;                } catch (JSONException e) {&#10;                    e.printStackTrace();&#10;                    &#10;                    // 7. Handle JSON parsing errors (ERROR STATE)&#10;                    apiResultTextView.setText(&quot;Error parsing data&quot;);&#10;                    Log.e(&quot;API_ERROR&quot;, &quot;JSON parsing failed: &quot; + e.getMessage());&#10;                }&#10;            }&#10;        }, new Response.ErrorListener() {&#10;            @Override&#10;            public void onErrorResponse(VolleyError error) {&#10;                // 8. Handle network/request errors (ERROR STATE)&#10;                apiResultTextView.setText(&quot;Error fetching data&quot;);&#10;                &#10;                // Log detailed error information&#10;                Log.e(&quot;API_ERROR&quot;, &quot;Request failed: &quot; + error.getMessage());&#10;                if (error.networkResponse != null) {&#10;                    Log.e(&quot;API_ERROR&quot;, &quot;Status Code: &quot; + error.networkResponse.statusCode);&#10;                }&#10;            }&#10;        }) {&#10;        &#10;        @Override&#10;        public Map&lt;String, String&gt; getHeaders() {&#10;            // 9. Add headers if needed&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);&#10;            headers.put(&quot;Accept&quot;, &quot;application/json&quot;);&#10;            headers.put(&quot;User-Agent&quot;, &quot;YourApp/1.0&quot;);&#10;            return headers;&#10;        }&#10;    };&#10;    &#10;    // 10. Set timeout and retry policy&#10;    stringRequest.setRetryPolicy(new DefaultRetryPolicy(&#10;        15000, // 15 seconds timeout&#10;        1,     // 1 retry attempt&#10;        DefaultRetryPolicy.DEFAULT_BACKOFF_MULT&#10;    ));&#10;    &#10;    // 11. Add request to queue&#10;    queue.add(stringRequest);&#10;}&#10;&#10;// UI STATE MANAGEMENT EXAMPLES&#10;&#10;// SUCCESS STATE - Show fetched data&#10;private void showSuccessState(String data) {&#10;    apiResultTextView.setText(&quot;Current Time: &quot; + data);&#10;    apiResultTextView.setTextColor(getResources().getColor(android.R.color.black));&#10;    apiResultTextView.setBackgroundColor(getResources().getColor(android.R.color.white));&#10;}&#10;&#10;// ERROR STATE - Show error message  &#10;private void showErrorState(String errorMessage) {&#10;    apiResultTextView.setText(errorMessage);&#10;    apiResultTextView.setTextColor(getResources().getColor(android.R.color.holo_red_dark));&#10;    apiResultTextView.setBackgroundColor(getResources().getColor(android.R.color.holo_red_light));&#10;}&#10;&#10;// LOADING STATE - Show loading indicator&#10;private void showLoadingState() {&#10;    apiResultTextView.setText(&quot;Loading current time...&quot;);&#10;    apiResultTextView.setTextColor(getResources().getColor(android.R.color.darker_gray));&#10;    apiResultTextView.setBackgroundColor(getResources().getColor(android.R.color.white));&#10;}&#10;&#10;// COMPLETE IMPLEMENTATION WITH UI STATES&#10;private void fetchAPIDataWithUIStates() {&#10;    // Show loading state&#10;    showLoadingState();&#10;    &#10;    String apiUrl = getString(R.string.world_time_api_url);&#10;    RequestQueue queue = Volley.newRequestQueue(this);&#10;    &#10;    StringRequest stringRequest = new StringRequest(Request.Method.GET, apiUrl,&#10;        response -&gt; {&#10;            try {&#10;                JSONObject jsonObject = new JSONObject(response);&#10;                String datetime = jsonObject.getString(&quot;datetime&quot;);&#10;                &#10;                // Show success state&#10;                showSuccessState(datetime);&#10;                &#10;            } catch (JSONException e) {&#10;                e.printStackTrace();&#10;                // Show error state for parsing errors&#10;                showErrorState(&quot;Error parsing server response&quot;);&#10;            }&#10;        },&#10;        error -&gt; {&#10;            // Show error state for network errors&#10;            if (error instanceof TimeoutError) {&#10;                showErrorState(&quot;Request timed out - check connection&quot;);&#10;            } else if (error instanceof NoConnectionError) {&#10;                showErrorState(&quot;No internet connection&quot;);&#10;            } else {&#10;                showErrorState(&quot;Error fetching data from server&quot;);&#10;            }&#10;        }&#10;    ) {&#10;        @Override&#10;        public Map&lt;String, String&gt; getHeaders() {&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            headers.put(&quot;Accept&quot;, &quot;application/json&quot;);&#10;            headers.put(&quot;User-Agent&quot;, &quot;StudyLog-Android-App&quot;);&#10;            return headers;&#10;        }&#10;    };&#10;    &#10;    stringRequest.setRetryPolicy(new DefaultRetryPolicy(15000, 1, 2.0f));&#10;    queue.add(stringRequest);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    package=&quot;com.example.studylog&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Required permission --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.MyApp&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    package=&quot;com.example.studylog&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Required permission --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.MyApp&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/studylog/MainActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/studylog/MainActivity.java" />
              <option name="originalContent" value="package com.example.studylog;&#10;&#10;import android.content.Intent;&#10;import android.net.Uri;&#10;import android.os.Bundle;&#10;import android.widget.Button;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import androidx.fragment.app.Fragment;&#10;&#10;import android.view.View;&#10;&#10;import com.android.volley.Request;&#10;import com.android.volley.RequestQueue;&#10;import com.android.volley.Response;&#10;import com.android.volley.VolleyError;&#10;import com.android.volley.toolbox.StringRequest;&#10;import com.android.volley.toolbox.Volley;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;&#10;import org.json.JSONException;&#10;import org.json.JSONObject;&#10;&#10;import com.example.studylog.R;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;    private TextView apiResultTextView;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setupUI();&#10;        setupBottomNavigation();&#10;        setupButtons();&#10;        fetchCurrentTime();&#10;    }&#10;&#10;    private void setupUI() {&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;        View root = findViewById(android.R.id.content);&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(root, (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;&#10;        apiResultTextView = findViewById(R.id.tv_api_result);&#10;    }&#10;&#10;    private void setupBottomNavigation() {&#10;        BottomNavigationView bottomNav = findViewById(R.id.bottom_nav);&#10;        bottomNav.setOnItemSelectedListener(this::handleNavigationItemSelected);&#10;        bottomNav.setSelectedItemId(R.id.nav_facts);&#10;    }&#10;&#10;    private boolean handleNavigationItemSelected(android.view.MenuItem item) {&#10;        Fragment fragment = createFragmentForMenuItem(item.getItemId());&#10;        getSupportFragmentManager().beginTransaction()&#10;                .replace(R.id.fragment_container, fragment)&#10;                .commit();&#10;        return true;&#10;    }&#10;&#10;    private Fragment createFragmentForMenuItem(int itemId) {&#10;        if (itemId == R.id.nav_tasks) {&#10;            return new TaskLogFragment();&#10;        } else if (itemId == R.id.nav_contact) {&#10;            return new ContactFragment();&#10;        } else if (itemId == R.id.nav_profile) {&#10;            return new ProfileFragment();&#10;        } else {&#10;            return new FactFeedFragment(); // default to facts&#10;        }&#10;    }&#10;&#10;    private void setupButtons() {&#10;        setupCallTutorButton();&#10;        setupFindLibraryButton();&#10;    }&#10;&#10;    private void setupCallTutorButton() {&#10;        Button btnCallTutor = findViewById(R.id.btn_call_tutor);&#10;        btnCallTutor.setOnClickListener(v -&gt; openPhoneDialer());&#10;    }&#10;&#10;    private void setupFindLibraryButton() {&#10;        Button btnFindLibrary = findViewById(R.id.btn_find_library);&#10;        btnFindLibrary.setOnClickListener(v -&gt; openLibraryMap());&#10;    }&#10;&#10;    private void openPhoneDialer() {&#10;        Intent dialIntent = new Intent(Intent.ACTION_DIAL);&#10;        dialIntent.setData(Uri.parse(getString(R.string.tutor_phone_number)));&#10;        if (dialIntent.resolveActivity(getPackageManager()) != null) {&#10;            startActivity(dialIntent);&#10;        }&#10;    }&#10;&#10;    private void openLibraryMap() {&#10;        Uri gmmIntentUri = Uri.parse(getString(R.string.library_search_query));&#10;        Intent mapIntent = new Intent(Intent.ACTION_VIEW, gmmIntentUri);&#10;        mapIntent.setPackage(getString(R.string.google_maps_package));&#10;        if (mapIntent.resolveActivity(getPackageManager()) != null) {&#10;            startActivity(mapIntent);&#10;        }&#10;    }&#10;&#10;    private void fetchCurrentTime() {&#10;        String apiUrl = getString(R.string.world_time_api_url);&#10;        RequestQueue queue = Volley.newRequestQueue(this);&#10;&#10;        StringRequest stringRequest = new StringRequest(&#10;            Request.Method.GET,&#10;            apiUrl,&#10;            this::handleApiResponse,&#10;            this::handleApiError&#10;        );&#10;&#10;        queue.add(stringRequest);&#10;    }&#10;&#10;    private void handleApiResponse(String response) {&#10;        try {&#10;            JSONObject jsonObject = new JSONObject(response);&#10;            String datetime = jsonObject.getString(getString(R.string.json_datetime_key));&#10;            String formattedResult = getString(R.string.api_result_current_time, datetime);&#10;            apiResultTextView.setText(formattedResult);&#10;        } catch (JSONException e) {&#10;            e.printStackTrace();&#10;            apiResultTextView.setText(getString(R.string.api_result_parse_error));&#10;        }&#10;    }&#10;&#10;    private void handleApiError(VolleyError error) {&#10;        apiResultTextView.setText(getString(R.string.api_result_network_error));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.studylog;&#10;&#10;import android.content.Intent;&#10;import android.net.Uri;&#10;import android.os.Bundle;&#10;import android.widget.Button;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import androidx.fragment.app.Fragment;&#10;&#10;import android.view.View;&#10;&#10;import com.android.volley.DefaultRetryPolicy;&#10;import com.android.volley.NetworkError;&#10;import com.android.volley.NoConnectionError;&#10;import com.android.volley.Request;&#10;import com.android.volley.RequestQueue;&#10;import com.android.volley.Response;&#10;import com.android.volley.TimeoutError;&#10;import com.android.volley.VolleyError;&#10;import com.android.volley.toolbox.StringRequest;&#10;import com.android.volley.toolbox.Volley;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;&#10;import org.json.JSONException;&#10;import org.json.JSONObject;&#10;&#10;import com.example.studylog.R;&#10;import android.util.Log;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;    private static final String TAG = &quot;MainActivity&quot;;&#10;    private TextView apiResultTextView;&#10;    private boolean hasTriedBackupAPI = false;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setupUI();&#10;        setupBottomNavigation();&#10;        setupButtons();&#10;        fetchCurrentTime();&#10;    }&#10;&#10;    private void setupUI() {&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;        View root = findViewById(android.R.id.content);&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(root, (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;&#10;        apiResultTextView = findViewById(R.id.tv_api_result);&#10;    }&#10;&#10;    private void setupBottomNavigation() {&#10;        BottomNavigationView bottomNav = findViewById(R.id.bottom_nav);&#10;        bottomNav.setOnItemSelectedListener(this::handleNavigationItemSelected);&#10;        bottomNav.setSelectedItemId(R.id.nav_facts);&#10;    }&#10;&#10;    private boolean handleNavigationItemSelected(android.view.MenuItem item) {&#10;        Fragment fragment = createFragmentForMenuItem(item.getItemId());&#10;        getSupportFragmentManager().beginTransaction()&#10;                .replace(R.id.fragment_container, fragment)&#10;                .commit();&#10;        return true;&#10;    }&#10;&#10;    private Fragment createFragmentForMenuItem(int itemId) {&#10;        if (itemId == R.id.nav_tasks) {&#10;            return new TaskLogFragment();&#10;        } else if (itemId == R.id.nav_contact) {&#10;            return new ContactFragment();&#10;        } else if (itemId == R.id.nav_profile) {&#10;            return new ProfileFragment();&#10;        } else {&#10;            return new FactFeedFragment(); // default to facts&#10;        }&#10;    }&#10;&#10;    private void setupButtons() {&#10;        setupCallTutorButton();&#10;        setupFindLibraryButton();&#10;    }&#10;&#10;    private void setupCallTutorButton() {&#10;        Button btnCallTutor = findViewById(R.id.btn_call_tutor);&#10;        btnCallTutor.setOnClickListener(v -&gt; openPhoneDialer());&#10;    }&#10;&#10;    private void setupFindLibraryButton() {&#10;        Button btnFindLibrary = findViewById(R.id.btn_find_library);&#10;        btnFindLibrary.setOnClickListener(v -&gt; openLibraryMap());&#10;    }&#10;&#10;    private void openPhoneDialer() {&#10;        Intent dialIntent = new Intent(Intent.ACTION_DIAL);&#10;        dialIntent.setData(Uri.parse(getString(R.string.tutor_phone_number)));&#10;        if (dialIntent.resolveActivity(getPackageManager()) != null) {&#10;            startActivity(dialIntent);&#10;        }&#10;    }&#10;&#10;    private void openLibraryMap() {&#10;        Uri gmmIntentUri = Uri.parse(getString(R.string.library_search_query));&#10;        Intent mapIntent = new Intent(Intent.ACTION_VIEW, gmmIntentUri);&#10;        mapIntent.setPackage(getString(R.string.google_maps_package));&#10;        if (mapIntent.resolveActivity(getPackageManager()) != null) {&#10;            startActivity(mapIntent);&#10;        }&#10;    }&#10;&#10;    private void fetchCurrentTime() {&#10;        // Use the standard Volley request implementation&#10;        makeStandardVolleyRequest();&#10;    }&#10;    &#10;    private void fetchCurrentTimeAdvanced() {&#10;        fetchCurrentTimeAdvanced(false);&#10;    }&#10;&#10;    private void fetchCurrentTimeAdvanced(boolean useBackupAPI) {&#10;        String apiUrl = useBackupAPI ?&#10;            getString(R.string.backup_time_api_url) :&#10;            getString(R.string.world_time_api_url);&#10;&#10;        Log.d(TAG, &quot;Fetching time from API: &quot; + apiUrl + &quot; (backup: &quot; + useBackupAPI + &quot;)&quot;);&#10;&#10;        // Set loading state&#10;        if (!useBackupAPI) {&#10;            apiResultTextView.setText(getString(R.string.api_result_default));&#10;        } else {&#10;            apiResultTextView.setText(&quot;Trying backup API...&quot;);&#10;        }&#10;&#10;        RequestQueue queue = Volley.newRequestQueue(this);&#10;&#10;        StringRequest stringRequest = new StringRequest(&#10;            Request.Method.GET,&#10;            apiUrl,&#10;            response -&gt; {&#10;                // Enhanced response logging&#10;                Log.d(TAG, &quot;=== API RESPONSE START ===&quot;);&#10;                Log.d(TAG, &quot;URL: &quot; + apiUrl);&#10;                Log.d(TAG, &quot;Response Length: &quot; + (response != null ? response.length() : &quot;null&quot;));&#10;                Log.d(TAG, &quot;Raw Response: &quot; + response);&#10;                Log.d(TAG, &quot;=== API RESPONSE END ===&quot;);&#10;&#10;                // Validate response before processing&#10;                if (response == null || response.trim().isEmpty()) {&#10;                    Log.e(TAG, &quot;Empty or null response received from API&quot;);&#10;                    apiResultTextView.setText(&quot;Empty response from server&quot;);&#10;                    return;&#10;                }&#10;&#10;                // Check if response looks like valid JSON&#10;                if (!response.trim().startsWith(&quot;{&quot;) &amp;&amp; !response.trim().startsWith(&quot;[&quot;)) {&#10;                    Log.e(TAG, &quot;Response doesn't appear to be JSON: &quot; + response.substring(0, Math.min(100, response.length())));&#10;                    apiResultTextView.setText(&quot;Invalid JSON response from server&quot;);&#10;                    return;&#10;                }&#10;&#10;                handleApiResponse(response, apiUrl);&#10;            },&#10;            error -&gt; {&#10;                // Enhanced error logging&#10;                Log.e(TAG, &quot;=== API ERROR START ===&quot;);&#10;                Log.e(TAG, &quot;URL: &quot; + apiUrl);&#10;                Log.e(TAG, &quot;Error Type: &quot; + error.getClass().getSimpleName());&#10;                Log.e(TAG, &quot;Error Message: &quot; + error.getMessage());&#10;&#10;                // Log network response details if available&#10;                if (error.networkResponse != null) {&#10;                    Log.e(TAG, &quot;HTTP Status Code: &quot; + error.networkResponse.statusCode);&#10;                    Log.e(TAG, &quot;Response Headers: &quot; + error.networkResponse.headers);&#10;&#10;                    if (error.networkResponse.data != null) {&#10;                        String errorData = new String(error.networkResponse.data);&#10;                        Log.e(TAG, &quot;Error Response Data: &quot; + errorData);&#10;&#10;                        // Try to parse error response as JSON for more details&#10;                        try {&#10;                            JSONObject errorJson = new JSONObject(errorData);&#10;                            Log.e(TAG, &quot;Parsed Error JSON: &quot; + errorJson.toString(2));&#10;                        } catch (JSONException e) {&#10;                            Log.e(TAG, &quot;Error response is not valid JSON&quot;);&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(TAG, &quot;No network response available&quot;);&#10;                }&#10;&#10;                // Log additional error details&#10;                if (error.getCause() != null) {&#10;                    Log.e(TAG, &quot;Error Cause: &quot; + error.getCause().getMessage());&#10;                }&#10;&#10;                Log.e(TAG, &quot;=== API ERROR END ===&quot;);&#10;&#10;                // Try backup API if primary fails and we haven't tried it yet&#10;                if (!useBackupAPI &amp;&amp; !hasTriedBackupAPI) {&#10;                    Log.d(TAG, &quot;Primary API failed, attempting backup API&quot;);&#10;                    hasTriedBackupAPI = true;&#10;                    fetchCurrentTimeAdvanced(true);&#10;                } else {&#10;                    handleApiError(error, useBackupAPI);&#10;                }&#10;            }&#10;        ) {&#10;            @Override&#10;            public java.util.Map&lt;String, String&gt; getHeaders() {&#10;                java.util.Map&lt;String, String&gt; headers = new java.util.HashMap&lt;&gt;();&#10;                headers.put(&quot;User-Agent&quot;, &quot;StudyLog-Android-App/1.0 (Android)&quot;);&#10;                headers.put(&quot;Accept&quot;, &quot;application/json, text/plain, */*&quot;);&#10;                headers.put(&quot;Accept-Encoding&quot;, &quot;gzip, deflate&quot;);&#10;                headers.put(&quot;Connection&quot;, &quot;keep-alive&quot;);&#10;                headers.put(&quot;Cache-Control&quot;, &quot;no-cache&quot;);&#10;&#10;                Log.d(TAG, &quot;Request Headers: &quot; + headers);&#10;                return headers;&#10;            }&#10;&#10;            @Override&#10;            protected void deliverResponse(String response) {&#10;                Log.d(TAG, &quot;Delivering response to UI thread&quot;);&#10;                super.deliverResponse(response);&#10;            }&#10;&#10;            @Override&#10;            public void deliverError(VolleyError error) {&#10;                Log.d(TAG, &quot;Delivering error to UI thread&quot;);&#10;                super.deliverError(error);&#10;            }&#10;        };&#10;&#10;        // Enhanced timeout and retry policy&#10;        stringRequest.setRetryPolicy(new DefaultRetryPolicy(&#10;            15000, // 15 seconds timeout (increased for slower networks)&#10;            1, // 1 retry attempt&#10;            2.0f // exponential backoff multiplier&#10;        ));&#10;&#10;        Log.d(TAG, &quot;Request configured with 15s timeout, 1 retry attempt&quot;);&#10;&#10;        queue.add(stringRequest);&#10;    }&#10;&#10;    private void handleApiResponse(String response, String apiUrl) {&#10;        try {&#10;            Log.d(TAG, &quot;=== PARSING API RESPONSE ===&quot;);&#10;            Log.d(TAG, &quot;API URL: &quot; + apiUrl);&#10;            Log.d(TAG, &quot;Response length: &quot; + response.length() + &quot; characters&quot;);&#10;&#10;            JSONObject jsonObject = new JSONObject(response);&#10;            Log.d(TAG, &quot;JSON parsed successfully&quot;);&#10;            Log.d(TAG, &quot;Available JSON keys: &quot; + jsonObject.keys());&#10;&#10;            String datetime = null;&#10;            String source = &quot;Unknown&quot;;&#10;&#10;            // Handle WorldTime API format (primary)&#10;            if (jsonObject.has(&quot;datetime&quot;)) {&#10;                datetime = jsonObject.getString(&quot;datetime&quot;);&#10;                source = &quot;WorldTime API&quot;;&#10;                Log.d(TAG, &quot;Found 'datetime' field: &quot; + datetime);&#10;            }&#10;            // Handle TimeAPI.io format (alternative)&#10;            else if (jsonObject.has(&quot;dateTime&quot;)) {&#10;                datetime = jsonObject.getString(&quot;dateTime&quot;);&#10;                source = &quot;TimeAPI.io&quot;;&#10;                Log.d(TAG, &quot;Found 'dateTime' field: &quot; + datetime);&#10;            }&#10;            // Handle other possible formats&#10;            else if (jsonObject.has(&quot;time&quot;)) {&#10;                datetime = jsonObject.getString(&quot;time&quot;);&#10;                source = &quot;Generic API&quot;;&#10;                Log.d(TAG, &quot;Found 'time' field: &quot; + datetime);&#10;            }&#10;            // Handle Unix timestamp format&#10;            else if (jsonObject.has(&quot;timestamp&quot;)) {&#10;                long timestamp = jsonObject.getLong(&quot;timestamp&quot;);&#10;                datetime = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.US)&#10;                    .format(new java.util.Date(timestamp * 1000));&#10;                source = &quot;Timestamp API&quot;;&#10;                Log.d(TAG, &quot;Found 'timestamp' field, converted to: &quot; + datetime);&#10;            }&#10;&#10;            if (datetime != null &amp;&amp; !datetime.trim().isEmpty()) {&#10;                // Log successful extraction&#10;                Log.d(TAG, &quot;DateTime successfully extracted: &quot; + datetime);&#10;                Log.d(TAG, &quot;Source: &quot; + source);&#10;&#10;                // Format and display the result&#10;                String formattedResult = getString(R.string.api_result_current_time, datetime);&#10;                Log.d(TAG, &quot;Formatted result: &quot; + formattedResult);&#10;&#10;                // Update UI on main thread&#10;                runOnUiThread(() -&gt; {&#10;                    apiResultTextView.setText(formattedResult);&#10;                    // Remove any click listeners since we succeeded&#10;                    apiResultTextView.setOnClickListener(null);&#10;                });&#10;&#10;                Log.d(TAG, &quot;Successfully updated UI with time from &quot; + source);&#10;&#10;                // Log additional useful information if available&#10;                logAdditionalApiInfo(jsonObject);&#10;&#10;            } else {&#10;                // No datetime field found&#10;                Log.e(TAG, &quot;No datetime field found in API response&quot;);&#10;                Log.e(TAG, &quot;Available fields: &quot; + jsonObject.keys());&#10;                Log.e(TAG, &quot;Full JSON response for debugging: &quot; + jsonObject.toString(2));&#10;&#10;                runOnUiThread(() -&gt; {&#10;                    apiResultTextView.setText(&quot;No time data found in API response&quot;);&#10;                });&#10;            }&#10;&#10;        } catch (JSONException e) {&#10;            Log.e(TAG, &quot;=== JSON PARSING ERROR ===&quot;);&#10;            Log.e(TAG, &quot;Error message: &quot; + e.getMessage());&#10;            Log.e(TAG, &quot;Error location: &quot; + e.getClass().getSimpleName());&#10;            Log.e(TAG, &quot;Response that failed to parse (first 500 chars): &quot; +&#10;                response.substring(0, Math.min(500, response.length())));&#10;&#10;            // Try to identify the issue&#10;            if (!response.trim().startsWith(&quot;{&quot;)) {&#10;                Log.e(TAG, &quot;Response doesn't start with '{' - not valid JSON object&quot;);&#10;                runOnUiThread(() -&gt; apiResultTextView.setText(&quot;Invalid JSON format received&quot;));&#10;            } else {&#10;                Log.e(TAG, &quot;Response appears to be JSON but parsing failed&quot;);&#10;                runOnUiThread(() -&gt; apiResultTextView.setText(getString(R.string.api_result_parse_error)));&#10;            }&#10;&#10;            // Log stack trace for debugging&#10;            Log.e(TAG, &quot;Full stack trace:&quot;, e);&#10;        }&#10;    }&#10;&#10;    private void logAdditionalApiInfo(JSONObject jsonObject) {&#10;        try {&#10;            // Log timezone info if available&#10;            if (jsonObject.has(&quot;timezone&quot;)) {&#10;                Log.d(TAG, &quot;Timezone: &quot; + jsonObject.getString(&quot;timezone&quot;));&#10;            }&#10;            if (jsonObject.has(&quot;utc_offset&quot;)) {&#10;                Log.d(TAG, &quot;UTC Offset: &quot; + jsonObject.getString(&quot;utc_offset&quot;));&#10;            }&#10;            if (jsonObject.has(&quot;day_of_week&quot;)) {&#10;                Log.d(TAG, &quot;Day of week: &quot; + jsonObject.getInt(&quot;day_of_week&quot;));&#10;            }&#10;            if (jsonObject.has(&quot;day_of_year&quot;)) {&#10;                Log.d(TAG, &quot;Day of year: &quot; + jsonObject.getInt(&quot;day_of_year&quot;));&#10;            }&#10;        } catch (JSONException e) {&#10;            Log.d(TAG, &quot;Additional API info logging failed: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Standard Volley Request Implementation&#10;     * This method follows the exact pattern specified by the user requirements&#10;     */&#10;    private void makeStandardVolleyRequest() {&#10;        // Use your actual API URL&#10;        String apiUrl = getString(R.string.world_time_api_url);&#10;        &#10;        // Set loading state in UI&#10;        apiResultTextView.setText(&quot;Loading current time...&quot;);&#10;        &#10;        RequestQueue queue = Volley.newRequestQueue(this);&#10;        StringRequest stringRequest = new StringRequest(Request.Method.GET, apiUrl,&#10;            new Response.Listener&lt;String&gt;() {&#10;                @Override&#10;                public void onResponse(String response) {&#10;                    try {&#10;                        JSONObject jsonObject = new JSONObject(response);&#10;                        // Parse the required data from the response (datetime field for WorldTime API)&#10;                        String data = jsonObject.getString(&quot;datetime&quot;);&#10;                        // Update the TextView with the data&#10;                        apiResultTextView.setText(&quot;Data: &quot; + data);&#10;                        Log.d(TAG, &quot;Successfully fetched and displayed data: &quot; + data);&#10;                    } catch (JSONException e) {&#10;                        e.printStackTrace();&#10;                        Log.e(TAG, &quot;JSON parsing error: &quot; + e.getMessage());&#10;                        apiResultTextView.setText(&quot;Error parsing data&quot;);&#10;                    }&#10;                }&#10;            }, new Response.ErrorListener() {&#10;                @Override&#10;                public void onErrorResponse(VolleyError error) {&#10;                    // Handle the error response&#10;                    Log.e(TAG, &quot;Standard Volley request failed: &quot; + error.getMessage());&#10;                    if (error.networkResponse != null) {&#10;                        Log.e(TAG, &quot;HTTP Status Code: &quot; + error.networkResponse.statusCode);&#10;                    }&#10;                    &#10;                    // Show basic error message first&#10;                    apiResultTextView.setText(&quot;Error fetching data - Tap to retry with diagnostics&quot;);&#10;                    &#10;                    // Add tap-to-retry with advanced diagnostics&#10;                    apiResultTextView.setOnClickListener(v -&gt; {&#10;                        Log.d(TAG, &quot;User tapped error message, starting advanced diagnostics&quot;);&#10;                        apiResultTextView.setOnClickListener(null); // Remove click listener&#10;                        fetchCurrentTimeAdvanced(); // Use advanced method with backup APIs&#10;                    });&#10;                }&#10;            }) {&#10;            &#10;            @Override&#10;            public java.util.Map&lt;String, String&gt; getHeaders() {&#10;                // Add proper headers for the API request&#10;                java.util.Map&lt;String, String&gt; headers = new java.util.HashMap&lt;&gt;();&#10;                headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);&#10;                headers.put(&quot;Accept&quot;, &quot;application/json&quot;);&#10;                headers.put(&quot;User-Agent&quot;, &quot;StudyLog-Android-App&quot;);&#10;                return headers;&#10;            }&#10;        };&#10;        &#10;        // Add timeout and retry policy&#10;        stringRequest.setRetryPolicy(new DefaultRetryPolicy(&#10;            15000, // 15 seconds timeout&#10;            1, // 1 retry&#10;            DefaultRetryPolicy.DEFAULT_BACKOFF_MULT&#10;        ));&#10;        &#10;        queue.add(stringRequest);&#10;    }&#10;&#10;    private void handleApiError(VolleyError error, boolean wasBackupAPI) {&#10;        Log.e(TAG, &quot;API request failed&quot;, error);&#10;&#10;        String errorMessage = getString(R.string.api_result_network_error);&#10;&#10;        if (error.networkResponse != null) {&#10;            int statusCode = error.networkResponse.statusCode;&#10;            Log.e(TAG, &quot;HTTP Status Code: &quot; + statusCode);&#10;&#10;            switch (statusCode) {&#10;                case 404:&#10;                    errorMessage = &quot;API endpoint not found (404)&quot;;&#10;                    break;&#10;                case 500:&#10;                    errorMessage = &quot;Server error occurred (500)&quot;;&#10;                    break;&#10;                case 403:&#10;                    errorMessage = &quot;Access denied to API (403)&quot;;&#10;                    break;&#10;                default:&#10;                    errorMessage = &quot;Network error (Code: &quot; + statusCode + &quot;)&quot;;&#10;                    break;&#10;            }&#10;        } else if (error instanceof TimeoutError) {&#10;            errorMessage = &quot;Request timeout - check connection&quot;;&#10;        } else if (error instanceof NoConnectionError) {&#10;            errorMessage = &quot;No internet connection available&quot;;&#10;        } else if (error instanceof NetworkError) {&#10;            errorMessage = &quot;Network error occurred&quot;;&#10;        }&#10;&#10;        if (wasBackupAPI) {&#10;            errorMessage += &quot; (Both APIs failed)&quot;;&#10;        }&#10;&#10;        // Add tap to retry functionality&#10;        errorMessage += &quot; - Tap to retry&quot;;&#10;        apiResultTextView.setText(errorMessage);&#10;        apiResultTextView.setOnClickListener(v -&gt; {&#10;            hasTriedBackupAPI = false; // Reset backup API flag&#10;            apiResultTextView.setOnClickListener(null); // Remove click listener&#10;&#10;            // Test all APIs to see which one works&#10;            testAllAPIs();&#10;        });&#10;&#10;        Log.e(TAG, &quot;Final error message: &quot; + errorMessage);&#10;    }&#10;&#10;    private void testAllAPIs() {&#10;        apiResultTextView.setText(&quot;Testing APIs...&quot;);&#10;        Log.d(TAG, &quot;Starting comprehensive API test&quot;);&#10;&#10;        // Test primary WorldTime API&#10;        testSingleAPI(&quot;https://worldtimeapi.org/api/timezone/Europe/London&quot;, &quot;datetime&quot;, &quot;Primary WorldTime API&quot;);&#10;    }&#10;&#10;    private void testSingleAPI(String url, String jsonKey, String apiName) {&#10;        Log.d(TAG, &quot;Testing &quot; + apiName + &quot;: &quot; + url);&#10;&#10;        RequestQueue queue = Volley.newRequestQueue(this);&#10;        StringRequest stringRequest = new StringRequest(&#10;            Request.Method.GET,&#10;            url,&#10;            response -&gt; {&#10;                Log.d(TAG, apiName + &quot; SUCCESS: &quot; + response);&#10;                try {&#10;                    JSONObject jsonObject = new JSONObject(response);&#10;                    if (jsonObject.has(jsonKey)) {&#10;                        String datetime = jsonObject.getString(jsonKey);&#10;                        String result = &quot;✅ &quot; + apiName + &quot; works!\nTime: &quot; + datetime;&#10;                        apiResultTextView.setText(result);&#10;                        Log.d(TAG, apiName + &quot; parsed successfully: &quot; + datetime);&#10;                    } else {&#10;                        Log.e(TAG, apiName + &quot; missing &quot; + jsonKey + &quot; field&quot;);&#10;                        apiResultTextView.setText(&quot;❌ &quot; + apiName + &quot; missing &quot; + jsonKey + &quot; field&quot;);&#10;                    }&#10;                } catch (JSONException e) {&#10;                    Log.e(TAG, apiName + &quot; JSON parse error&quot;, e);&#10;                    apiResultTextView.setText(&quot;❌ &quot; + apiName + &quot; JSON error: &quot; + e.getMessage());&#10;                }&#10;            },&#10;            error -&gt; {&#10;                Log.e(TAG, apiName + &quot; FAILED&quot;, error);&#10;                String errorMsg = &quot;❌ &quot; + apiName + &quot; failed: &quot;;&#10;&#10;                if (error.networkResponse != null) {&#10;                    errorMsg += &quot;HTTP &quot; + error.networkResponse.statusCode;&#10;                } else if (error instanceof TimeoutError) {&#10;                    errorMsg += &quot;Timeout&quot;;&#10;                } else if (error instanceof NoConnectionError) {&#10;                    errorMsg += &quot;No connection&quot;;&#10;                } else {&#10;                    errorMsg += &quot;Network error&quot;;&#10;                }&#10;&#10;                // Try alternative APIs&#10;                if (url.contains(&quot;worldtimeapi.org&quot;) &amp;&amp; url.startsWith(&quot;https&quot;)) {&#10;                    Log.d(TAG, &quot;HTTPS failed, trying HTTP&quot;);&#10;                    testSingleAPI(&quot;http://worldtimeapi.org/api/timezone/Europe/London&quot;, &quot;datetime&quot;, &quot;HTTP WorldTime API&quot;);&#10;                } else if (url.contains(&quot;worldtimeapi.org&quot;)) {&#10;                    Log.d(TAG, &quot;WorldTime API failed, trying TimeAPI.io&quot;);&#10;                    testSingleAPI(&quot;https://timeapi.io/api/Time/current/zone?timeZone=Europe/London&quot;, &quot;dateTime&quot;, &quot;TimeAPI.io&quot;);&#10;                } else {&#10;                    // All APIs failed&#10;                    apiResultTextView.setText(errorMsg + &quot;\n\nAll APIs failed. Check internet connection.&quot;);&#10;                }&#10;            }&#10;        ) {&#10;            @Override&#10;            public java.util.Map&lt;String, String&gt; getHeaders() {&#10;                java.util.Map&lt;String, String&gt; headers = new java.util.HashMap&lt;&gt;();&#10;                headers.put(&quot;User-Agent&quot;, &quot;StudyLog-Android-App/1.0&quot;);&#10;                headers.put(&quot;Accept&quot;, &quot;application/json&quot;);&#10;                return headers;&#10;            }&#10;        };&#10;&#10;        // Set timeout&#10;        stringRequest.setRetryPolicy(new DefaultRetryPolicy(&#10;            15000, // 15 seconds&#10;            0, // no retries&#10;            DefaultRetryPolicy.DEFAULT_BACKOFF_MULT&#10;        ));&#10;&#10;        queue.add(stringRequest);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/strings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/strings.xml" />
              <option name="originalContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;MyApp&lt;/string&gt;&#10;&#10;    &lt;!-- Button texts --&gt;&#10;    &lt;string name=&quot;btn_call_tutor&quot;&gt;Call Tutor&lt;/string&gt;&#10;    &lt;string name=&quot;btn_find_library&quot;&gt;Find Library&lt;/string&gt;&#10;&#10;    &lt;!-- API result messages --&gt;&#10;    &lt;string name=&quot;api_result_default&quot;&gt;Loading current time…&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_current_time&quot;&gt;Current Date/Time: %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_parse_error&quot;&gt;Error parsing date/time&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_network_error&quot;&gt;Error fetching data&lt;/string&gt;&#10;&#10;    &lt;!-- Phone and map intents --&gt;&#10;    &lt;string name=&quot;tutor_phone_number&quot;&gt;tel:+1234567890&lt;/string&gt;&#10;    &lt;string name=&quot;library_search_query&quot;&gt;geo:0,0?q=library+near+me&lt;/string&gt;&#10;    &lt;string name=&quot;google_maps_package&quot;&gt;com.google.android.apps.maps&lt;/string&gt;&#10;&#10;    &lt;!-- API --&gt;&#10;    &lt;string name=&quot;world_time_api_url&quot;&gt;https://worldtimeapi.org/api/timezone/Europe/London&lt;/string&gt;&#10;    &lt;string name=&quot;json_datetime_key&quot;&gt;datetime&lt;/string&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;MyApp&lt;/string&gt;&#10;&#10;    &lt;!-- Button texts --&gt;&#10;    &lt;string name=&quot;btn_call_tutor&quot;&gt;Call Tutor&lt;/string&gt;&#10;    &lt;string name=&quot;btn_find_library&quot;&gt;Find Library&lt;/string&gt;&#10;&#10;    &lt;!-- API result messages --&gt;&#10;    &lt;string name=&quot;api_result_default&quot;&gt;Loading current time…&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_current_time&quot;&gt;Current Date/Time: %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_parse_error&quot;&gt;Error parsing date/time&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_network_error&quot;&gt;Error fetching data&lt;/string&gt;&#10;&#10;    &lt;!-- Phone and map intents --&gt;&#10;    &lt;string name=&quot;tutor_phone_number&quot;&gt;tel:+1234567890&lt;/string&gt;&#10;    &lt;string name=&quot;library_search_query&quot;&gt;geo:0,0?q=library+near+me&lt;/string&gt;&#10;    &lt;string name=&quot;google_maps_package&quot;&gt;com.google.android.apps.maps&lt;/string&gt;&#10;&#10;    &lt;!-- API --&gt;&#10;    &lt;string name=&quot;world_time_api_url&quot;&gt;https://worldtimeapi.org/api/timezone/Europe/London&lt;/string&gt;&#10;    &lt;string name=&quot;backup_time_api_url&quot;&gt;http://worldtimeapi.org/api/timezone/Europe/London&lt;/string&gt;&#10;    &lt;string name=&quot;simple_time_api_url&quot;&gt;https://timeapi.io/api/Time/current/zone?timeZone=Europe/London&lt;/string&gt;&#10;    &lt;string name=&quot;json_datetime_key&quot;&gt;datetime&lt;/string&gt;&#10;    &lt;string name=&quot;json_simple_time_key&quot;&gt;dateTime&lt;/string&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;worldtimeapi.org&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;api.worldtimeapi.org&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;    &#10;    &lt;!-- Allow all HTTPS traffic --&gt;&#10;    &lt;base-config cleartextTrafficPermitted=&quot;false&quot;&gt;&#10;        &lt;trust-anchors&gt;&#10;            &lt;certificates src=&quot;system&quot;/&gt;&#10;        &lt;/trust-anchors&gt;&#10;    &lt;/base-config&gt;&#10;&lt;/network-security-config&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>