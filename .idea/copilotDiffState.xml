<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/API_DEBUG_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/API_DEBUG_GUIDE.md" />
              <option name="updatedContent" value="# API Integration Debug Guide&#10;&#10;## Issue: App showing &quot;Error fetching data&quot;&#10;&#10;## Fixes Applied:&#10;&#10;### 1. Enhanced Error Handling &amp; Logging&#10;- Added comprehensive logging with TAG &quot;MainActivity&quot;&#10;- Added specific error messages for different HTTP status codes&#10;- Added timeout and network error detection&#10;- Added JSON parsing error handling&#10;&#10;### 2. Network Security Configuration&#10;- Created `network_security_config.xml` to handle HTTPS/HTTP issues&#10;- Added `android:usesCleartextTraffic=&quot;true&quot;` in AndroidManifest&#10;- Allow cleartext traffic for worldtimeapi.org domain&#10;&#10;### 3. Backup API System&#10;- Primary: `https://worldtimeapi.org/api/timezone/Europe/London`&#10;- Backup: `http://worldtimeapi.org/api/timezone/Europe/London` (HTTP fallback)&#10;- Alternative: `https://timeapi.io/api/Time/current/zone?timeZone=Europe/London`&#10;&#10;### 4. Comprehensive API Testing&#10;- Added `testAllAPIs()` method to test all endpoints&#10;- Click &quot;Error fetching data&quot; text to run full API diagnostics&#10;- Will show which API works and detailed error messages&#10;&#10;### 5. Improved Request Configuration&#10;- Added proper User-Agent header&#10;- Added Accept: application/json header&#10;- Increased timeout to 15 seconds&#10;- Disabled automatic retries to avoid delays&#10;&#10;## Testing Steps:&#10;&#10;### Method 1: Check Logs&#10;1. Connect device/emulator to Android Studio&#10;2. Open Logcat and filter by &quot;MainActivity&quot;&#10;3. Launch app and watch for API logs&#10;4. Look for specific error messages&#10;&#10;### Method 2: Use Built-in Diagnostics&#10;1. Launch the app&#10;2. If you see &quot;Error fetching data&quot;, tap on the text&#10;3. App will run comprehensive API tests&#10;4. Will show which API works or specific error messages&#10;&#10;### Method 3: Manual API Testing&#10;Test the APIs directly:&#10;- Primary: `curl &quot;https://worldtimeapi.org/api/timezone/Europe/London&quot;`&#10;- Backup: `curl &quot;http://worldtimeapi.org/api/timezone/Europe/London&quot;`&#10;- Alternative: `curl &quot;https://timeapi.io/api/Time/current/zone?timeZone=Europe/London&quot;`&#10;&#10;## Expected Behavior:&#10;- Loading: &quot;Loading current time...&quot;&#10;- Success: &quot;Current Date/Time: 2024-11-12T14:30:25.123456+00:00&quot;&#10;- Error: Specific error message + &quot;- Tap to retry&quot;&#10;&#10;## Common Issues &amp; Solutions:&#10;&#10;### 1. SSL/TLS Issues&#10;- **Solution**: Network security config allows both HTTP and HTTPS&#10;- **Backup**: Falls back to HTTP if HTTPS fails&#10;&#10;### 2. API Endpoint Down&#10;- **Solution**: Multiple backup APIs configured&#10;- **Fallback**: TimeAPI.io as alternative service&#10;&#10;### 3. Network Connectivity&#10;- **Detection**: Shows &quot;No internet connection available&quot;&#10;- **Solution**: Check device network settings&#10;&#10;### 4. Firewall/Corporate Network&#10;- **Detection**: Shows timeout or connection errors&#10;- **Solution**: May need to test on different network&#10;&#10;### 5. JSON Parsing Issues&#10;- **Detection**: Shows &quot;Error parsing date/time&quot;&#10;- **Logging**: Full response logged for debugging&#10;&#10;## Debug Commands:&#10;```bash&#10;# Build and install&#10;./gradlew assembleDebug&#10;&#10;# Install on connected device&#10;adb install app/build/outputs/apk/debug/app-debug.apk&#10;&#10;# View real-time logs&#10;adb logcat | grep MainActivity&#10;```&#10;&#10;## Files Modified:&#10;- `MainActivity.java` - Enhanced API integration with comprehensive error handling&#10;- `AndroidManifest.xml` - Added network security configuration&#10;- `res/xml/network_security_config.xml` - Network security rules&#10;- `res/values/strings.xml` - Added backup API URLs&#10;&#10;The app should now provide detailed error messages and automatically try multiple APIs to ensure the time data loads successfully." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/VOLLEY_REQUEST_EXAMPLE.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/VOLLEY_REQUEST_EXAMPLE.java" />
              <option name="updatedContent" value="/**&#10; * VOLLEY REQUEST IMPLEMENTATION - COMPLETE EXAMPLE&#10; * This file demonstrates the exact Volley request pattern specified by the user&#10; */&#10;&#10;// STANDARD VOLLEY REQUEST IMPLEMENTATION&#10;private void makeAPIRequest() {&#10;    // 1. Set up the API URL&#10;    String apiUrl = &quot;https://worldtimeapi.org/api/timezone/Europe/London&quot;; // Use your actual API URL&#10;    &#10;    // 2. Update UI to show loading state&#10;    apiResultTextView.setText(&quot;Loading...&quot;);&#10;    &#10;    // 3. Create Volley RequestQueue&#10;    RequestQueue queue = Volley.newRequestQueue(this);&#10;    &#10;    // 4. Create StringRequest with proper error handling&#10;    StringRequest stringRequest = new StringRequest(Request.Method.GET, apiUrl,&#10;        new Response.Listener&lt;String&gt;() {&#10;            @Override&#10;            public void onResponse(String response) {&#10;                try {&#10;                    // 5. Parse the JSON response&#10;                    JSONObject jsonObject = new JSONObject(response);&#10;                    String data = jsonObject.getString(&quot;datetime&quot;); // Parse the required data from the response&#10;                    &#10;                    // 6. Update the TextView with the data (SUCCESS STATE)&#10;                    apiResultTextView.setText(&quot;Data: &quot; + data); // Update the TextView with the data&#10;                    &#10;                    Log.d(&quot;API_SUCCESS&quot;, &quot;Data fetched successfully: &quot; + data);&#10;                    &#10;                } catch (JSONException e) {&#10;                    e.printStackTrace();&#10;                    &#10;                    // 7. Handle JSON parsing errors (ERROR STATE)&#10;                    apiResultTextView.setText(&quot;Error parsing data&quot;);&#10;                    Log.e(&quot;API_ERROR&quot;, &quot;JSON parsing failed: &quot; + e.getMessage());&#10;                }&#10;            }&#10;        }, new Response.ErrorListener() {&#10;            @Override&#10;            public void onErrorResponse(VolleyError error) {&#10;                // 8. Handle network/request errors (ERROR STATE)&#10;                apiResultTextView.setText(&quot;Error fetching data&quot;);&#10;                &#10;                // Log detailed error information&#10;                Log.e(&quot;API_ERROR&quot;, &quot;Request failed: &quot; + error.getMessage());&#10;                if (error.networkResponse != null) {&#10;                    Log.e(&quot;API_ERROR&quot;, &quot;Status Code: &quot; + error.networkResponse.statusCode);&#10;                }&#10;            }&#10;        }) {&#10;        &#10;        @Override&#10;        public Map&lt;String, String&gt; getHeaders() {&#10;            // 9. Add headers if needed&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);&#10;            headers.put(&quot;Accept&quot;, &quot;application/json&quot;);&#10;            headers.put(&quot;User-Agent&quot;, &quot;YourApp/1.0&quot;);&#10;            return headers;&#10;        }&#10;    };&#10;    &#10;    // 10. Set timeout and retry policy&#10;    stringRequest.setRetryPolicy(new DefaultRetryPolicy(&#10;        15000, // 15 seconds timeout&#10;        1,     // 1 retry attempt&#10;        DefaultRetryPolicy.DEFAULT_BACKOFF_MULT&#10;    ));&#10;    &#10;    // 11. Add request to queue&#10;    queue.add(stringRequest);&#10;}&#10;&#10;// UI STATE MANAGEMENT EXAMPLES&#10;&#10;// SUCCESS STATE - Show fetched data&#10;private void showSuccessState(String data) {&#10;    apiResultTextView.setText(&quot;Current Time: &quot; + data);&#10;    apiResultTextView.setTextColor(getResources().getColor(android.R.color.black));&#10;    apiResultTextView.setBackgroundColor(getResources().getColor(android.R.color.white));&#10;}&#10;&#10;// ERROR STATE - Show error message  &#10;private void showErrorState(String errorMessage) {&#10;    apiResultTextView.setText(errorMessage);&#10;    apiResultTextView.setTextColor(getResources().getColor(android.R.color.holo_red_dark));&#10;    apiResultTextView.setBackgroundColor(getResources().getColor(android.R.color.holo_red_light));&#10;}&#10;&#10;// LOADING STATE - Show loading indicator&#10;private void showLoadingState() {&#10;    apiResultTextView.setText(&quot;Loading current time...&quot;);&#10;    apiResultTextView.setTextColor(getResources().getColor(android.R.color.darker_gray));&#10;    apiResultTextView.setBackgroundColor(getResources().getColor(android.R.color.white));&#10;}&#10;&#10;// COMPLETE IMPLEMENTATION WITH UI STATES&#10;private void fetchAPIDataWithUIStates() {&#10;    // Show loading state&#10;    showLoadingState();&#10;    &#10;    String apiUrl = getString(R.string.world_time_api_url);&#10;    RequestQueue queue = Volley.newRequestQueue(this);&#10;    &#10;    StringRequest stringRequest = new StringRequest(Request.Method.GET, apiUrl,&#10;        response -&gt; {&#10;            try {&#10;                JSONObject jsonObject = new JSONObject(response);&#10;                String datetime = jsonObject.getString(&quot;datetime&quot;);&#10;                &#10;                // Show success state&#10;                showSuccessState(datetime);&#10;                &#10;            } catch (JSONException e) {&#10;                e.printStackTrace();&#10;                // Show error state for parsing errors&#10;                showErrorState(&quot;Error parsing server response&quot;);&#10;            }&#10;        },&#10;        error -&gt; {&#10;            // Show error state for network errors&#10;            if (error instanceof TimeoutError) {&#10;                showErrorState(&quot;Request timed out - check connection&quot;);&#10;            } else if (error instanceof NoConnectionError) {&#10;                showErrorState(&quot;No internet connection&quot;);&#10;            } else {&#10;                showErrorState(&quot;Error fetching data from server&quot;);&#10;            }&#10;        }&#10;    ) {&#10;        @Override&#10;        public Map&lt;String, String&gt; getHeaders() {&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            headers.put(&quot;Accept&quot;, &quot;application/json&quot;);&#10;            headers.put(&quot;User-Agent&quot;, &quot;StudyLog-Android-App&quot;);&#10;            return headers;&#10;        }&#10;    };&#10;    &#10;    stringRequest.setRetryPolicy(new DefaultRetryPolicy(15000, 1, 2.0f));&#10;    queue.add(stringRequest);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    package=&quot;com.example.studylog&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Required permission --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.MyApp&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    package=&quot;com.example.studylog&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Required permission --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.MyApp&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/studylog/MainActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/studylog/MainActivity.java" />
              <option name="originalContent" value="package com.example.studylog;&#10;&#10;import android.content.Intent;&#10;import android.net.Uri;&#10;import android.os.Bundle;&#10;import android.widget.Button;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import androidx.fragment.app.Fragment;&#10;&#10;import android.view.View;&#10;&#10;import com.android.volley.Request;&#10;import com.android.volley.RequestQueue;&#10;import com.android.volley.Response;&#10;import com.android.volley.VolleyError;&#10;import com.android.volley.toolbox.StringRequest;&#10;import com.android.volley.toolbox.Volley;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;&#10;import org.json.JSONException;&#10;import org.json.JSONObject;&#10;&#10;import com.example.studylog.R;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;    private TextView apiResultTextView;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setupUI();&#10;        setupBottomNavigation();&#10;        setupButtons();&#10;        fetchCurrentTime();&#10;    }&#10;&#10;    private void setupUI() {&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;        View root = findViewById(android.R.id.content);&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(root, (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;&#10;        apiResultTextView = findViewById(R.id.tv_api_result);&#10;    }&#10;&#10;    private void setupBottomNavigation() {&#10;        BottomNavigationView bottomNav = findViewById(R.id.bottom_nav);&#10;        bottomNav.setOnItemSelectedListener(this::handleNavigationItemSelected);&#10;        bottomNav.setSelectedItemId(R.id.nav_facts);&#10;    }&#10;&#10;    private boolean handleNavigationItemSelected(android.view.MenuItem item) {&#10;        Fragment fragment = createFragmentForMenuItem(item.getItemId());&#10;        getSupportFragmentManager().beginTransaction()&#10;                .replace(R.id.fragment_container, fragment)&#10;                .commit();&#10;        return true;&#10;    }&#10;&#10;    private Fragment createFragmentForMenuItem(int itemId) {&#10;        if (itemId == R.id.nav_tasks) {&#10;            return new TaskLogFragment();&#10;        } else if (itemId == R.id.nav_contact) {&#10;            return new ContactFragment();&#10;        } else if (itemId == R.id.nav_profile) {&#10;            return new ProfileFragment();&#10;        } else {&#10;            return new FactFeedFragment(); // default to facts&#10;        }&#10;    }&#10;&#10;    private void setupButtons() {&#10;        setupCallTutorButton();&#10;        setupFindLibraryButton();&#10;    }&#10;&#10;    private void setupCallTutorButton() {&#10;        Button btnCallTutor = findViewById(R.id.btn_call_tutor);&#10;        btnCallTutor.setOnClickListener(v -&gt; openPhoneDialer());&#10;    }&#10;&#10;    private void setupFindLibraryButton() {&#10;        Button btnFindLibrary = findViewById(R.id.btn_find_library);&#10;        btnFindLibrary.setOnClickListener(v -&gt; openLibraryMap());&#10;    }&#10;&#10;    private void openPhoneDialer() {&#10;        Intent dialIntent = new Intent(Intent.ACTION_DIAL);&#10;        dialIntent.setData(Uri.parse(getString(R.string.tutor_phone_number)));&#10;        if (dialIntent.resolveActivity(getPackageManager()) != null) {&#10;            startActivity(dialIntent);&#10;        }&#10;    }&#10;&#10;    private void openLibraryMap() {&#10;        Uri gmmIntentUri = Uri.parse(getString(R.string.library_search_query));&#10;        Intent mapIntent = new Intent(Intent.ACTION_VIEW, gmmIntentUri);&#10;        mapIntent.setPackage(getString(R.string.google_maps_package));&#10;        if (mapIntent.resolveActivity(getPackageManager()) != null) {&#10;            startActivity(mapIntent);&#10;        }&#10;    }&#10;&#10;    private void fetchCurrentTime() {&#10;        String apiUrl = getString(R.string.world_time_api_url);&#10;        RequestQueue queue = Volley.newRequestQueue(this);&#10;&#10;        StringRequest stringRequest = new StringRequest(&#10;            Request.Method.GET,&#10;            apiUrl,&#10;            this::handleApiResponse,&#10;            this::handleApiError&#10;        );&#10;&#10;        queue.add(stringRequest);&#10;    }&#10;&#10;    private void handleApiResponse(String response) {&#10;        try {&#10;            JSONObject jsonObject = new JSONObject(response);&#10;            String datetime = jsonObject.getString(getString(R.string.json_datetime_key));&#10;            String formattedResult = getString(R.string.api_result_current_time, datetime);&#10;            apiResultTextView.setText(formattedResult);&#10;        } catch (JSONException e) {&#10;            e.printStackTrace();&#10;            apiResultTextView.setText(getString(R.string.api_result_parse_error));&#10;        }&#10;    }&#10;&#10;    private void handleApiError(VolleyError error) {&#10;        apiResultTextView.setText(getString(R.string.api_result_network_error));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.studylog;&#10;&#10;import android.content.Intent;&#10;import android.net.Uri;&#10;import android.os.Bundle;&#10;import android.widget.Button;&#10;import android.widget.TextView;&#10;&#10;import androidx.activity.EdgeToEdge;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.graphics.Insets;&#10;import androidx.core.view.ViewCompat;&#10;import androidx.core.view.WindowInsetsCompat;&#10;&#10;import androidx.fragment.app.Fragment;&#10;&#10;import android.view.View;&#10;&#10;import com.android.volley.DefaultRetryPolicy;&#10;import com.android.volley.NetworkError;&#10;import com.android.volley.NoConnectionError;&#10;import com.android.volley.Request;&#10;import com.android.volley.RequestQueue;&#10;import com.android.volley.Response;&#10;import com.android.volley.TimeoutError;&#10;import com.android.volley.VolleyError;&#10;import com.android.volley.toolbox.StringRequest;&#10;import com.android.volley.toolbox.Volley;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;&#10;import org.json.JSONException;&#10;import org.json.JSONObject;&#10;&#10;import com.example.studylog.R;&#10;import android.util.Log;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;    private static final String TAG = &quot;MainActivity&quot;;&#10;    private TextView apiResultTextView;&#10;    private boolean hasTriedBackupAPI = false;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setupUI();&#10;        setupBottomNavigation();&#10;        setupButtons();&#10;        fetchCurrentTime();&#10;    }&#10;&#10;    private void setupUI() {&#10;        EdgeToEdge.enable(this);&#10;        setContentView(R.layout.activity_main);&#10;        View root = findViewById(android.R.id.content);&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(root, (v, insets) -&gt; {&#10;            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);&#10;            return insets;&#10;        });&#10;&#10;        apiResultTextView = findViewById(R.id.tv_api_result);&#10;    }&#10;&#10;    private void setupBottomNavigation() {&#10;        BottomNavigationView bottomNav = findViewById(R.id.bottom_nav);&#10;        bottomNav.setOnItemSelectedListener(this::handleNavigationItemSelected);&#10;        bottomNav.setSelectedItemId(R.id.nav_facts);&#10;    }&#10;&#10;    private boolean handleNavigationItemSelected(android.view.MenuItem item) {&#10;        Fragment fragment = createFragmentForMenuItem(item.getItemId());&#10;        getSupportFragmentManager().beginTransaction()&#10;                .replace(R.id.fragment_container, fragment)&#10;                .commit();&#10;        return true;&#10;    }&#10;&#10;    private Fragment createFragmentForMenuItem(int itemId) {&#10;        if (itemId == R.id.nav_tasks) {&#10;            return new TaskLogFragment();&#10;        } else if (itemId == R.id.nav_contact) {&#10;            return new ContactFragment();&#10;        } else if (itemId == R.id.nav_profile) {&#10;            return new ProfileFragment();&#10;        } else {&#10;            return new FactFeedFragment(); // default to facts&#10;        }&#10;    }&#10;&#10;    private void setupButtons() {&#10;        setupCallTutorButton();&#10;        setupFindLibraryButton();&#10;    }&#10;&#10;    private void setupCallTutorButton() {&#10;        Button btnCallTutor = findViewById(R.id.btn_call_tutor);&#10;        btnCallTutor.setOnClickListener(v -&gt; openPhoneDialer());&#10;    }&#10;&#10;    private void setupFindLibraryButton() {&#10;        Button btnFindLibrary = findViewById(R.id.btn_find_library);&#10;        btnFindLibrary.setOnClickListener(v -&gt; openLibraryMap());&#10;    }&#10;&#10;    private void openPhoneDialer() {&#10;        Intent dialIntent = new Intent(Intent.ACTION_DIAL);&#10;        dialIntent.setData(Uri.parse(getString(R.string.tutor_phone_number)));&#10;        if (dialIntent.resolveActivity(getPackageManager()) != null) {&#10;            startActivity(dialIntent);&#10;        }&#10;    }&#10;&#10;    private void openLibraryMap() {&#10;        Uri gmmIntentUri = Uri.parse(getString(R.string.library_search_query));&#10;        Intent mapIntent = new Intent(Intent.ACTION_VIEW, gmmIntentUri);&#10;        mapIntent.setPackage(getString(R.string.google_maps_package));&#10;        if (mapIntent.resolveActivity(getPackageManager()) != null) {&#10;            startActivity(mapIntent);&#10;        }&#10;    }&#10;&#10;    private void fetchCurrentTime() {&#10;        // Use the standard Volley request implementation&#10;        makeStandardVolleyRequest();&#10;    }&#10;    &#10;    private void fetchCurrentTimeAdvanced() {&#10;        fetchCurrentTimeAdvanced(false);&#10;    }&#10;&#10;    private void fetchCurrentTimeAdvanced(boolean useBackupAPI) {&#10;        String apiUrl = useBackupAPI ?&#10;            getString(R.string.backup_time_api_url) :&#10;            getString(R.string.world_time_api_url);&#10;&#10;        Log.d(TAG, &quot;Fetching time from API: &quot; + apiUrl + &quot; (backup: &quot; + useBackupAPI + &quot;)&quot;);&#10;&#10;        // Set loading state&#10;        if (!useBackupAPI) {&#10;            apiResultTextView.setText(getString(R.string.api_result_default));&#10;        } else {&#10;            apiResultTextView.setText(&quot;Trying backup API...&quot;);&#10;        }&#10;&#10;        RequestQueue queue = Volley.newRequestQueue(this);&#10;&#10;        StringRequest stringRequest = new StringRequest(&#10;            Request.Method.GET,&#10;            apiUrl,&#10;            response -&gt; {&#10;                // Enhanced response logging&#10;                Log.d(TAG, &quot;=== API RESPONSE START ===&quot;);&#10;                Log.d(TAG, &quot;URL: &quot; + apiUrl);&#10;                Log.d(TAG, &quot;Response Length: &quot; + (response != null ? response.length() : &quot;null&quot;));&#10;                Log.d(TAG, &quot;Raw Response: &quot; + response);&#10;                Log.d(TAG, &quot;=== API RESPONSE END ===&quot;);&#10;&#10;                // Validate response before processing&#10;                if (response == null || response.trim().isEmpty()) {&#10;                    Log.e(TAG, &quot;Empty or null response received from API&quot;);&#10;                    apiResultTextView.setText(&quot;Empty response from server&quot;);&#10;                    return;&#10;                }&#10;&#10;                // Check if response looks like valid JSON&#10;                if (!response.trim().startsWith(&quot;{&quot;) &amp;&amp; !response.trim().startsWith(&quot;[&quot;)) {&#10;                    Log.e(TAG, &quot;Response doesn't appear to be JSON: &quot; + response.substring(0, Math.min(100, response.length())));&#10;                    apiResultTextView.setText(&quot;Invalid JSON response from server&quot;);&#10;                    return;&#10;                }&#10;&#10;                handleApiResponse(response, apiUrl);&#10;            },&#10;            error -&gt; {&#10;                // Enhanced error logging&#10;                Log.e(TAG, &quot;=== API ERROR START ===&quot;);&#10;                Log.e(TAG, &quot;URL: &quot; + apiUrl);&#10;                Log.e(TAG, &quot;Error Type: &quot; + error.getClass().getSimpleName());&#10;                Log.e(TAG, &quot;Error Message: &quot; + error.getMessage());&#10;&#10;                // Log network response details if available&#10;                if (error.networkResponse != null) {&#10;                    Log.e(TAG, &quot;HTTP Status Code: &quot; + error.networkResponse.statusCode);&#10;                    Log.e(TAG, &quot;Response Headers: &quot; + error.networkResponse.headers);&#10;&#10;                    if (error.networkResponse.data != null) {&#10;                        String errorData = new String(error.networkResponse.data);&#10;                        Log.e(TAG, &quot;Error Response Data: &quot; + errorData);&#10;&#10;                        // Try to parse error response as JSON for more details&#10;                        try {&#10;                            JSONObject errorJson = new JSONObject(errorData);&#10;                            Log.e(TAG, &quot;Parsed Error JSON: &quot; + errorJson.toString(2));&#10;                        } catch (JSONException e) {&#10;                            Log.e(TAG, &quot;Error response is not valid JSON&quot;);&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(TAG, &quot;No network response available&quot;);&#10;                }&#10;&#10;                // Log additional error details&#10;                if (error.getCause() != null) {&#10;                    Log.e(TAG, &quot;Error Cause: &quot; + error.getCause().getMessage());&#10;                }&#10;&#10;                Log.e(TAG, &quot;=== API ERROR END ===&quot;);&#10;&#10;                // Try backup API if primary fails and we haven't tried it yet&#10;                if (!useBackupAPI &amp;&amp; !hasTriedBackupAPI) {&#10;                    Log.d(TAG, &quot;Primary API failed, attempting backup API&quot;);&#10;                    hasTriedBackupAPI = true;&#10;                    fetchCurrentTimeAdvanced(true);&#10;                } else {&#10;                    handleApiError(error, useBackupAPI);&#10;                }&#10;            }&#10;        ) {&#10;            @Override&#10;            public java.util.Map&lt;String, String&gt; getHeaders() {&#10;                java.util.Map&lt;String, String&gt; headers = new java.util.HashMap&lt;&gt;();&#10;                headers.put(&quot;User-Agent&quot;, &quot;StudyLog-Android-App/1.0 (Android)&quot;);&#10;                headers.put(&quot;Accept&quot;, &quot;application/json, text/plain, */*&quot;);&#10;                headers.put(&quot;Accept-Encoding&quot;, &quot;gzip, deflate&quot;);&#10;                headers.put(&quot;Connection&quot;, &quot;keep-alive&quot;);&#10;                headers.put(&quot;Cache-Control&quot;, &quot;no-cache&quot;);&#10;&#10;                Log.d(TAG, &quot;Request Headers: &quot; + headers);&#10;                return headers;&#10;            }&#10;&#10;            @Override&#10;            protected void deliverResponse(String response) {&#10;                Log.d(TAG, &quot;Delivering response to UI thread&quot;);&#10;                super.deliverResponse(response);&#10;            }&#10;&#10;            @Override&#10;            public void deliverError(VolleyError error) {&#10;                Log.d(TAG, &quot;Delivering error to UI thread&quot;);&#10;                super.deliverError(error);&#10;            }&#10;        };&#10;&#10;        // Enhanced timeout and retry policy&#10;        stringRequest.setRetryPolicy(new DefaultRetryPolicy(&#10;            15000, // 15 seconds timeout (increased for slower networks)&#10;            1, // 1 retry attempt&#10;            2.0f // exponential backoff multiplier&#10;        ));&#10;&#10;        Log.d(TAG, &quot;Request configured with 15s timeout, 1 retry attempt&quot;);&#10;&#10;        queue.add(stringRequest);&#10;    }&#10;&#10;    private void handleApiResponse(String response, String apiUrl) {&#10;        try {&#10;            Log.d(TAG, &quot;=== PARSING API RESPONSE ===&quot;);&#10;            Log.d(TAG, &quot;API URL: &quot; + apiUrl);&#10;            Log.d(TAG, &quot;Response length: &quot; + response.length() + &quot; characters&quot;);&#10;&#10;            JSONObject jsonObject = new JSONObject(response);&#10;            Log.d(TAG, &quot;JSON parsed successfully&quot;);&#10;            Log.d(TAG, &quot;Available JSON keys: &quot; + jsonObject.keys());&#10;&#10;            String datetime = null;&#10;            String source = &quot;Unknown&quot;;&#10;&#10;            // Handle WorldTime API format (primary)&#10;            if (jsonObject.has(&quot;datetime&quot;)) {&#10;                datetime = jsonObject.getString(&quot;datetime&quot;);&#10;                source = &quot;WorldTime API&quot;;&#10;                Log.d(TAG, &quot;Found 'datetime' field: &quot; + datetime);&#10;            }&#10;            // Handle TimeAPI.io format (alternative)&#10;            else if (jsonObject.has(&quot;dateTime&quot;)) {&#10;                datetime = jsonObject.getString(&quot;dateTime&quot;);&#10;                source = &quot;TimeAPI.io&quot;;&#10;                Log.d(TAG, &quot;Found 'dateTime' field: &quot; + datetime);&#10;            }&#10;            // Handle other possible formats&#10;            else if (jsonObject.has(&quot;time&quot;)) {&#10;                datetime = jsonObject.getString(&quot;time&quot;);&#10;                source = &quot;Generic API&quot;;&#10;                Log.d(TAG, &quot;Found 'time' field: &quot; + datetime);&#10;            }&#10;            // Handle Unix timestamp format&#10;            else if (jsonObject.has(&quot;timestamp&quot;)) {&#10;                long timestamp = jsonObject.getLong(&quot;timestamp&quot;);&#10;                datetime = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, java.util.Locale.US)&#10;                    .format(new java.util.Date(timestamp * 1000));&#10;                source = &quot;Timestamp API&quot;;&#10;                Log.d(TAG, &quot;Found 'timestamp' field, converted to: &quot; + datetime);&#10;            }&#10;&#10;            if (datetime != null &amp;&amp; !datetime.trim().isEmpty()) {&#10;                // Log successful extraction&#10;                Log.d(TAG, &quot;DateTime successfully extracted: &quot; + datetime);&#10;                Log.d(TAG, &quot;Source: &quot; + source);&#10;&#10;                // Format and display the result&#10;                String formattedResult = getString(R.string.api_result_current_time, datetime);&#10;                Log.d(TAG, &quot;Formatted result: &quot; + formattedResult);&#10;&#10;                // Update UI on main thread&#10;                runOnUiThread(() -&gt; {&#10;                    apiResultTextView.setText(formattedResult);&#10;                    // Remove any click listeners since we succeeded&#10;                    apiResultTextView.setOnClickListener(null);&#10;                });&#10;&#10;                Log.d(TAG, &quot;Successfully updated UI with time from &quot; + source);&#10;&#10;                // Log additional useful information if available&#10;                logAdditionalApiInfo(jsonObject);&#10;&#10;            } else {&#10;                // No datetime field found&#10;                Log.e(TAG, &quot;No datetime field found in API response&quot;);&#10;                Log.e(TAG, &quot;Available fields: &quot; + jsonObject.keys());&#10;                Log.e(TAG, &quot;Full JSON response for debugging: &quot; + jsonObject.toString(2));&#10;&#10;                runOnUiThread(() -&gt; {&#10;                    apiResultTextView.setText(&quot;No time data found in API response&quot;);&#10;                });&#10;            }&#10;&#10;        } catch (JSONException e) {&#10;            Log.e(TAG, &quot;=== JSON PARSING ERROR ===&quot;);&#10;            Log.e(TAG, &quot;Error message: &quot; + e.getMessage());&#10;            Log.e(TAG, &quot;Error location: &quot; + e.getClass().getSimpleName());&#10;            Log.e(TAG, &quot;Response that failed to parse (first 500 chars): &quot; +&#10;                response.substring(0, Math.min(500, response.length())));&#10;&#10;            // Try to identify the issue&#10;            if (!response.trim().startsWith(&quot;{&quot;)) {&#10;                Log.e(TAG, &quot;Response doesn't start with '{' - not valid JSON object&quot;);&#10;                runOnUiThread(() -&gt; apiResultTextView.setText(&quot;Invalid JSON format received&quot;));&#10;            } else {&#10;                Log.e(TAG, &quot;Response appears to be JSON but parsing failed&quot;);&#10;                runOnUiThread(() -&gt; apiResultTextView.setText(getString(R.string.api_result_parse_error)));&#10;            }&#10;&#10;            // Log stack trace for debugging&#10;            Log.e(TAG, &quot;Full stack trace:&quot;, e);&#10;        }&#10;    }&#10;&#10;    private void logAdditionalApiInfo(JSONObject jsonObject) {&#10;        try {&#10;            // Log timezone info if available&#10;            if (jsonObject.has(&quot;timezone&quot;)) {&#10;                Log.d(TAG, &quot;Timezone: &quot; + jsonObject.getString(&quot;timezone&quot;));&#10;            }&#10;            if (jsonObject.has(&quot;utc_offset&quot;)) {&#10;                Log.d(TAG, &quot;UTC Offset: &quot; + jsonObject.getString(&quot;utc_offset&quot;));&#10;            }&#10;            if (jsonObject.has(&quot;day_of_week&quot;)) {&#10;                Log.d(TAG, &quot;Day of week: &quot; + jsonObject.getInt(&quot;day_of_week&quot;));&#10;            }&#10;            if (jsonObject.has(&quot;day_of_year&quot;)) {&#10;                Log.d(TAG, &quot;Day of year: &quot; + jsonObject.getInt(&quot;day_of_year&quot;));&#10;            }&#10;        } catch (JSONException e) {&#10;            Log.d(TAG, &quot;Additional API info logging failed: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Standard Volley Request Implementation&#10;     * This method follows the exact pattern specified by the user requirements&#10;     */&#10;    private void makeStandardVolleyRequest() {&#10;        // Use your actual API URL&#10;        String apiUrl = getString(R.string.world_time_api_url);&#10;        &#10;        // Set loading state in UI&#10;        apiResultTextView.setText(&quot;Loading current time...&quot;);&#10;        &#10;        RequestQueue queue = Volley.newRequestQueue(this);&#10;        StringRequest stringRequest = new StringRequest(Request.Method.GET, apiUrl,&#10;            new Response.Listener&lt;String&gt;() {&#10;                @Override&#10;                public void onResponse(String response) {&#10;                    try {&#10;                        JSONObject jsonObject = new JSONObject(response);&#10;                        // Parse the required data from the response (datetime field for WorldTime API)&#10;                        String data = jsonObject.getString(&quot;datetime&quot;);&#10;                        // Update the TextView with the data&#10;                        apiResultTextView.setText(&quot;Data: &quot; + data);&#10;                        Log.d(TAG, &quot;Successfully fetched and displayed data: &quot; + data);&#10;                    } catch (JSONException e) {&#10;                        e.printStackTrace();&#10;                        Log.e(TAG, &quot;JSON parsing error: &quot; + e.getMessage());&#10;                        apiResultTextView.setText(&quot;Error parsing data&quot;);&#10;                    }&#10;                }&#10;            }, new Response.ErrorListener() {&#10;                @Override&#10;                public void onErrorResponse(VolleyError error) {&#10;                    // Handle the error response&#10;                    Log.e(TAG, &quot;Standard Volley request failed: &quot; + error.getMessage());&#10;                    if (error.networkResponse != null) {&#10;                        Log.e(TAG, &quot;HTTP Status Code: &quot; + error.networkResponse.statusCode);&#10;                    }&#10;                    &#10;                    // Show basic error message first&#10;                    apiResultTextView.setText(&quot;Error fetching data - Tap to retry with diagnostics&quot;);&#10;                    &#10;                    // Add tap-to-retry with advanced diagnostics&#10;                    apiResultTextView.setOnClickListener(v -&gt; {&#10;                        Log.d(TAG, &quot;User tapped error message, starting advanced diagnostics&quot;);&#10;                        apiResultTextView.setOnClickListener(null); // Remove click listener&#10;                        fetchCurrentTimeAdvanced(); // Use advanced method with backup APIs&#10;                    });&#10;                }&#10;            }) {&#10;            &#10;            @Override&#10;            public java.util.Map&lt;String, String&gt; getHeaders() {&#10;                // Add proper headers for the API request&#10;                java.util.Map&lt;String, String&gt; headers = new java.util.HashMap&lt;&gt;();&#10;                headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);&#10;                headers.put(&quot;Accept&quot;, &quot;application/json&quot;);&#10;                headers.put(&quot;User-Agent&quot;, &quot;StudyLog-Android-App&quot;);&#10;                return headers;&#10;            }&#10;        };&#10;        &#10;        // Add timeout and retry policy&#10;        stringRequest.setRetryPolicy(new DefaultRetryPolicy(&#10;            15000, // 15 seconds timeout&#10;            1, // 1 retry&#10;            DefaultRetryPolicy.DEFAULT_BACKOFF_MULT&#10;        ));&#10;        &#10;        queue.add(stringRequest);&#10;    }&#10;&#10;    private void handleApiError(VolleyError error, boolean wasBackupAPI) {&#10;        Log.e(TAG, &quot;API request failed&quot;, error);&#10;&#10;        String errorMessage = getString(R.string.api_result_network_error);&#10;&#10;        if (error.networkResponse != null) {&#10;            int statusCode = error.networkResponse.statusCode;&#10;            Log.e(TAG, &quot;HTTP Status Code: &quot; + statusCode);&#10;&#10;            switch (statusCode) {&#10;                case 404:&#10;                    errorMessage = &quot;API endpoint not found (404)&quot;;&#10;                    break;&#10;                case 500:&#10;                    errorMessage = &quot;Server error occurred (500)&quot;;&#10;                    break;&#10;                case 403:&#10;                    errorMessage = &quot;Access denied to API (403)&quot;;&#10;                    break;&#10;                default:&#10;                    errorMessage = &quot;Network error (Code: &quot; + statusCode + &quot;)&quot;;&#10;                    break;&#10;            }&#10;        } else if (error instanceof TimeoutError) {&#10;            errorMessage = &quot;Request timeout - check connection&quot;;&#10;        } else if (error instanceof NoConnectionError) {&#10;            errorMessage = &quot;No internet connection available&quot;;&#10;        } else if (error instanceof NetworkError) {&#10;            errorMessage = &quot;Network error occurred&quot;;&#10;        }&#10;&#10;        if (wasBackupAPI) {&#10;            errorMessage += &quot; (Both APIs failed)&quot;;&#10;        }&#10;&#10;        // Add tap to retry functionality&#10;        errorMessage += &quot; - Tap to retry&quot;;&#10;        apiResultTextView.setText(errorMessage);&#10;        apiResultTextView.setOnClickListener(v -&gt; {&#10;            hasTriedBackupAPI = false; // Reset backup API flag&#10;            apiResultTextView.setOnClickListener(null); // Remove click listener&#10;&#10;            // Test all APIs to see which one works&#10;            testAllAPIs();&#10;        });&#10;&#10;        Log.e(TAG, &quot;Final error message: &quot; + errorMessage);&#10;    }&#10;&#10;    private void testAllAPIs() {&#10;        apiResultTextView.setText(&quot;Testing APIs...&quot;);&#10;        Log.d(TAG, &quot;Starting comprehensive API test&quot;);&#10;&#10;        // Test primary WorldTime API&#10;        testSingleAPI(&quot;https://worldtimeapi.org/api/timezone/Europe/London&quot;, &quot;datetime&quot;, &quot;Primary WorldTime API&quot;);&#10;    }&#10;&#10;    private void testSingleAPI(String url, String jsonKey, String apiName) {&#10;        Log.d(TAG, &quot;Testing &quot; + apiName + &quot;: &quot; + url);&#10;&#10;        RequestQueue queue = Volley.newRequestQueue(this);&#10;        StringRequest stringRequest = new StringRequest(&#10;            Request.Method.GET,&#10;            url,&#10;            response -&gt; {&#10;                Log.d(TAG, apiName + &quot; SUCCESS: &quot; + response);&#10;                try {&#10;                    JSONObject jsonObject = new JSONObject(response);&#10;                    if (jsonObject.has(jsonKey)) {&#10;                        String datetime = jsonObject.getString(jsonKey);&#10;                        String result = &quot;✅ &quot; + apiName + &quot; works!\nTime: &quot; + datetime;&#10;                        apiResultTextView.setText(result);&#10;                        Log.d(TAG, apiName + &quot; parsed successfully: &quot; + datetime);&#10;                    } else {&#10;                        Log.e(TAG, apiName + &quot; missing &quot; + jsonKey + &quot; field&quot;);&#10;                        apiResultTextView.setText(&quot;❌ &quot; + apiName + &quot; missing &quot; + jsonKey + &quot; field&quot;);&#10;                    }&#10;                } catch (JSONException e) {&#10;                    Log.e(TAG, apiName + &quot; JSON parse error&quot;, e);&#10;                    apiResultTextView.setText(&quot;❌ &quot; + apiName + &quot; JSON error: &quot; + e.getMessage());&#10;                }&#10;            },&#10;            error -&gt; {&#10;                Log.e(TAG, apiName + &quot; FAILED&quot;, error);&#10;                String errorMsg = &quot;❌ &quot; + apiName + &quot; failed: &quot;;&#10;&#10;                if (error.networkResponse != null) {&#10;                    errorMsg += &quot;HTTP &quot; + error.networkResponse.statusCode;&#10;                } else if (error instanceof TimeoutError) {&#10;                    errorMsg += &quot;Timeout&quot;;&#10;                } else if (error instanceof NoConnectionError) {&#10;                    errorMsg += &quot;No connection&quot;;&#10;                } else {&#10;                    errorMsg += &quot;Network error&quot;;&#10;                }&#10;&#10;                // Try alternative APIs&#10;                if (url.contains(&quot;worldtimeapi.org&quot;) &amp;&amp; url.startsWith(&quot;https&quot;)) {&#10;                    Log.d(TAG, &quot;HTTPS failed, trying HTTP&quot;);&#10;                    testSingleAPI(&quot;http://worldtimeapi.org/api/timezone/Europe/London&quot;, &quot;datetime&quot;, &quot;HTTP WorldTime API&quot;);&#10;                } else if (url.contains(&quot;worldtimeapi.org&quot;)) {&#10;                    Log.d(TAG, &quot;WorldTime API failed, trying TimeAPI.io&quot;);&#10;                    testSingleAPI(&quot;https://timeapi.io/api/Time/current/zone?timeZone=Europe/London&quot;, &quot;dateTime&quot;, &quot;TimeAPI.io&quot;);&#10;                } else {&#10;                    // All APIs failed&#10;                    apiResultTextView.setText(errorMsg + &quot;\n\nAll APIs failed. Check internet connection.&quot;);&#10;                }&#10;            }&#10;        ) {&#10;            @Override&#10;            public java.util.Map&lt;String, String&gt; getHeaders() {&#10;                java.util.Map&lt;String, String&gt; headers = new java.util.HashMap&lt;&gt;();&#10;                headers.put(&quot;User-Agent&quot;, &quot;StudyLog-Android-App/1.0&quot;);&#10;                headers.put(&quot;Accept&quot;, &quot;application/json&quot;);&#10;                return headers;&#10;            }&#10;        };&#10;&#10;        // Set timeout&#10;        stringRequest.setRetryPolicy(new DefaultRetryPolicy(&#10;            15000, // 15 seconds&#10;            0, // no retries&#10;            DefaultRetryPolicy.DEFAULT_BACKOFF_MULT&#10;        ));&#10;&#10;        queue.add(stringRequest);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/strings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/strings.xml" />
              <option name="originalContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;MyApp&lt;/string&gt;&#10;&#10;    &lt;!-- Button texts --&gt;&#10;    &lt;string name=&quot;btn_call_tutor&quot;&gt;Call Tutor&lt;/string&gt;&#10;    &lt;string name=&quot;btn_find_library&quot;&gt;Find Library&lt;/string&gt;&#10;&#10;    &lt;!-- API result messages --&gt;&#10;    &lt;string name=&quot;api_result_default&quot;&gt;Loading current time…&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_current_time&quot;&gt;Current Date/Time: %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_parse_error&quot;&gt;Error parsing date/time&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_network_error&quot;&gt;Error fetching data&lt;/string&gt;&#10;&#10;    &lt;!-- Phone and map intents --&gt;&#10;    &lt;string name=&quot;tutor_phone_number&quot;&gt;tel:+1234567890&lt;/string&gt;&#10;    &lt;string name=&quot;library_search_query&quot;&gt;geo:0,0?q=library+near+me&lt;/string&gt;&#10;    &lt;string name=&quot;google_maps_package&quot;&gt;com.google.android.apps.maps&lt;/string&gt;&#10;&#10;    &lt;!-- API --&gt;&#10;    &lt;string name=&quot;world_time_api_url&quot;&gt;https://worldtimeapi.org/api/timezone/Europe/London&lt;/string&gt;&#10;    &lt;string name=&quot;json_datetime_key&quot;&gt;datetime&lt;/string&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;MyApp&lt;/string&gt;&#10;&#10;    &lt;!-- Button texts --&gt;&#10;    &lt;string name=&quot;btn_call_tutor&quot;&gt;Call Tutor&lt;/string&gt;&#10;    &lt;string name=&quot;btn_find_library&quot;&gt;Find Library&lt;/string&gt;&#10;&#10;    &lt;!-- API result messages --&gt;&#10;    &lt;string name=&quot;api_result_default&quot;&gt;Loading current time…&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_current_time&quot;&gt;Current Date/Time: %1$s&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_parse_error&quot;&gt;Error parsing date/time&lt;/string&gt;&#10;    &lt;string name=&quot;api_result_network_error&quot;&gt;Error fetching data&lt;/string&gt;&#10;&#10;    &lt;!-- Phone and map intents --&gt;&#10;    &lt;string name=&quot;tutor_phone_number&quot;&gt;tel:+1234567890&lt;/string&gt;&#10;    &lt;string name=&quot;library_search_query&quot;&gt;geo:0,0?q=library+near+me&lt;/string&gt;&#10;    &lt;string name=&quot;google_maps_package&quot;&gt;com.google.android.apps.maps&lt;/string&gt;&#10;&#10;    &lt;!-- API --&gt;&#10;    &lt;string name=&quot;world_time_api_url&quot;&gt;https://worldtimeapi.org/api/timezone/Europe/London&lt;/string&gt;&#10;    &lt;string name=&quot;backup_time_api_url&quot;&gt;http://worldtimeapi.org/api/timezone/Europe/London&lt;/string&gt;&#10;    &lt;string name=&quot;simple_time_api_url&quot;&gt;https://timeapi.io/api/Time/current/zone?timeZone=Europe/London&lt;/string&gt;&#10;    &lt;string name=&quot;json_datetime_key&quot;&gt;datetime&lt;/string&gt;&#10;    &lt;string name=&quot;json_simple_time_key&quot;&gt;dateTime&lt;/string&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;worldtimeapi.org&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;api.worldtimeapi.org&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;    &#10;    &lt;!-- Allow all HTTPS traffic --&gt;&#10;    &lt;base-config cleartextTrafficPermitted=&quot;false&quot;&gt;&#10;        &lt;trust-anchors&gt;&#10;            &lt;certificates src=&quot;system&quot;/&gt;&#10;        &lt;/trust-anchors&gt;&#10;    &lt;/base-config&gt;&#10;&lt;/network-security-config&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>